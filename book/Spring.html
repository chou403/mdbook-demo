<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Spring - chou401</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Algorithm.html"><strong aria-hidden="true">1.</strong> Algorithm</a></li><li class="chapter-item expanded "><a href="BlockingQueue.html"><strong aria-hidden="true">2.</strong> BlockingQueue</a></li><li class="chapter-item expanded "><a href="CompletableFuture.html"><strong aria-hidden="true">3.</strong> CompletableFuture</a></li><li class="chapter-item expanded "><a href="Docker.html"><strong aria-hidden="true">4.</strong> Docker</a></li><li class="chapter-item expanded "><a href="GC.html"><strong aria-hidden="true">5.</strong> GC</a></li><li class="chapter-item expanded "><a href="Interview.html"><strong aria-hidden="true">6.</strong> Interview</a></li><li class="chapter-item expanded "><a href="JDBC.html"><strong aria-hidden="true">7.</strong> JDBC</a></li><li class="chapter-item expanded "><a href="Jenkins.html"><strong aria-hidden="true">8.</strong> Jenkins</a></li><li class="chapter-item expanded "><a href="Lock.html"><strong aria-hidden="true">9.</strong> Lock</a></li><li class="chapter-item expanded "><a href="MQ.html"><strong aria-hidden="true">10.</strong> MQ</a></li><li class="chapter-item expanded "><a href="Mybatis.html"><strong aria-hidden="true">11.</strong> Mybatis</a></li><li class="chapter-item expanded "><a href="Mysql.html"><strong aria-hidden="true">12.</strong> Mysql</a></li><li class="chapter-item expanded "><a href="Netty.html"><strong aria-hidden="true">13.</strong> Netty</a></li><li class="chapter-item expanded "><a href="Slf4j.html"><strong aria-hidden="true">14.</strong> Slf4j</a></li><li class="chapter-item expanded "><a href="Spring.html" class="active"><strong aria-hidden="true">15.</strong> Spring</a></li><li class="chapter-item expanded "><a href="ThreadPool.html"><strong aria-hidden="true">16.</strong> ThreadPool</a></li><li class="chapter-item expanded "><a href="Tools.html"><strong aria-hidden="true">17.</strong> Tools</a></li><li class="chapter-item expanded "><a href="Typora.html"><strong aria-hidden="true">18.</strong> Typora</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">chou401</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chou401/chou401.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="spring"><a class="header" href="#spring">Spring</a></h1>
<h2 id="常见异常"><a class="header" href="#常见异常">常见异常</a></h2>
<div class="table-wrapper"><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody>
<tr><td>ClassCastException</td><td>类型强制转换异常</td></tr>
<tr><td>NegativeArrayException</td><td>数组负下标异常</td></tr>
<tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界异常</td></tr>
<tr><td>SecturityException</td><td>违背安全原则异常</td></tr>
<tr><td>EOFException</td><td>文件已结束异常</td></tr>
<tr><td>FileNotFoundException</td><td>文件未找到异常</td></tr>
<tr><td>NumberFormatException</td><td>字符串转换为数字异常</td></tr>
<tr><td>SQLException</td><td>操作数据库异常</td></tr>
<tr><td>IOException</td><td>输入输出异常</td></tr>
<tr><td>NoSuchMethodException</td><td>方法未找到异常</td></tr>
<tr><td>Java.lang.AbstractMethodError</td><td>抽象方法错误。当应用试图调用抽象方法时抛出。</td></tr>
<tr><td>java.lang.AssertionError</td><td>断言错。用来指示一个断言失败的情况。</td></tr>
<tr><td>java.lang.ClassCircularityError</td><td>类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。</td></tr>
<tr><td>java.lang.ClassFormatError</td><td>类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。</td></tr>
<tr><td>java.lang.Error</td><td>错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。</td></tr>
<tr><td>java.lang.ExceptionInInitializerError</td><td>初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。</td></tr>
<tr><td>java.lang.IllegalAccessError</td><td>违法访问错误。当一个应用试图访问、修改某个类的域(Field)或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</td></tr>
<tr><td>java.lang.IncompatibleClassChangeError</td><td>不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。</td></tr>
<tr><td>java.lang.InstantiationError</td><td>实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</td></tr>
<tr><td>java.lang.InternalError</td><td>内部错误。用于指示Java虚拟机发生了内部错误。</td></tr>
<tr><td>java.lang.LinkageError</td><td>链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。</td></tr>
<tr><td>java.lang.NoClassDefFoundError</td><td>未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。</td></tr>
<tr><td>java.lang.NoSuchFieldError</td><td>域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。</td></tr>
<tr><td>java.lang.NoSuchMethodError</td><td>方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。</td></tr>
<tr><td>java.lang.OutOfMemoryError</td><td>内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</td></tr>
<tr><td>java.lang.StackOverflowError</td><td>堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。</td></tr>
<tr><td>java.lang.ThreadDeath</td><td>线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。</td></tr>
<tr><td>java.lang.UnknownError</td><td>未知错误。用于指示Java虚拟机发生了未知严重错误的情况。</td></tr>
<tr><td>java.lang.UnsatisfiedLinkError</td><td>未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。</td></tr>
<tr><td>java.lang.UnsupportedClassVersionError</td><td>不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。</td></tr>
<tr><td>java.lang.VerifyError</td><td>验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。</td></tr>
<tr><td>java.lang.VirtualMachineError</td><td>虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况</td></tr>
</tbody></table>
</div>
<h2 id="lambda"><a class="header" href="#lambda">lambda</a></h2>
<p>求两个对象 list 的交集</p>
<pre><code class="language-java">private List&lt;People&gt; sameList(List&lt;People&gt; oldArrayList, List&lt;People&gt; newArrayList) {
    List&lt;People&gt; resultList = newArrayList.stream()
            .filter(item -&gt; oldArrayList.stream().map(e -&gt; e.getCode())
                    .collect(Collectors.toList()).contains(item.getCode()))
            .collect(Collectors.toList());
    return resultList;
}
</code></pre>
<p>求两个对象 list 的差集</p>
<pre><code class="language-java">private List&lt;People&gt; diffList(List&lt;People&gt; firstArrayList, List&lt;People&gt; secondArrayList) {
        List&lt;People&gt; resultList = firstArrayList.stream()
                .filter(item -&gt; !secondArrayList.stream().map(e -&gt; e.getCode()).collect(Collectors.toList()).contains(item.getCode()))
                .collect(Collectors.toList());
        return resultList;
    }
</code></pre>
<p>list 去除另一个 list 重复元素的数据</p>
<pre><code class="language-java">firstList.removeIf(first -&gt; secondList.stream().anyMatch(second -&gt; first.getCode().equals(second.getCode())));
</code></pre>
<h2 id="正则"><a class="header" href="#正则">正则</a></h2>
<p>(?!0(.0+)?$) 使用负向前瞻，排除0、0.0、0.00等数字。</p>
<p>(?!0+(.\d+)?$) 使用负向前瞻，排除以0开头的数字，如0.123、0.001等。</p>
<p>\d+(.\d+)? 匹配正整数和小数，其中小数点后面至少有一位数字</p>
<h2 id="spring-boot"><a class="header" href="#spring-boot">Spring boot</a></h2>
<p>为什么打成的jar包，通过java -jar xxx.jar 就能启动运行？</p>
<p>jar包里面含有一下三部分文件</p>
<p><img src="https://github.com/chou401/pic-md/raw/master/img/image-20230404172555912.png" alt="image-20230404172555912" /></p>
<blockquote>
<p>org：主要存放springboot相关的class文件
META-INF：主要存放maven和MANIFEST.MF文件
BOOT-INF/classes：主要存放应用编译后的class文件
BOOT-INF/lib：主要存放应用依赖的jar包文件</p>
</blockquote>
<p>打开META-INF下MENIFEST.MF文件，内容如下：</p>
<p><img src="https://github.com/chou401/pic-md/raw/master/img/image-20230404172728434.png" alt="image-20230404172728434" /></p>
<p>从上述MANIFEST.MF中可以看到Main-Class及Start-Class配置，其中Main-Class指定jar文件的入口类JarLauncher，当使用java -jar执行jar包的时候会调用JarLauncher的main方法，而不是我们编写的启动类。</p>
<p>JarLauncher叫做jar包启动器，当我们运行java -jar 的时候就会找到这个启动器。</p>
<p>这个启动器是我们在打包的时候弄进去的，也就是我们在pom文件中加入的插件：</p>
<pre><code class="language-xml">&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<blockquote>
<p>注意：
只有添加了spring-boot-maven-plugin插件，运行mvn:package命令后打成的jar包才能直接运行。</p>
</blockquote>
<p>这个插件在打包时候就会把jar启动器添加进去。</p>
<p><strong>java -jar 做了什么</strong></p>
<blockquote>
<p>官网对java -jar的解释如下：</p>
<p>If the -jar option is specified, its argument is the name of the JAR file containing class and resource files for the application. The startup class must be indicated by the Main-Class manifest header in its source code.</p>
<p>如果指定了-jar选项，它的参数是包含应用程序的类和资源文件的JAR文件的名称。启动类必须由其源代码中的Main-Class清单头指明。</p>
</blockquote>
<p>由此可见：当使用java -jar 启动springboot jar包时是去找Manifast.MF文件中的Main-Class指定的类来启动项目。</p>
<p><strong>JarLauncher的执行流程</strong></p>
<blockquote>
<p>org.springframework.boot.loader.JarLauncher#main
org.springframework.boot.loader.Launcher#launch(java.lang.String[])
org.springframework.boot.loader.Launcher#launch(java.lang.String[], java.lang.String, java.lang.ClassLoader) 中的第二个参数mainClass-》org.springframework.boot.loader.ExecutableArchiveLauncher#getMainClass
org.springframework.boot.loader.Launcher#createMainMethodRunner
org.springframework.boot.loader.MainMethodRunner#run</p>
</blockquote>
<p>添加spring-boot-loader依赖，才可以查看源码</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-loader&lt;/artifactId&gt;
	&lt;version&gt;2.1.16.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">package org.springframework.boot.loader;
 
import org.springframework.boot.loader.archive.Archive;
 
/**
 * {@link Launcher} for JAR based archives. This launcher assumes that dependency jars are
 * included inside a {@code /BOOT-INF/lib} directory and that application classes are
 * included inside a {@code /BOOT-INF/classes} directory.
 *
 * {@link Launcher}用于基于JAR的档案。该启动程序假设依赖jar包含在{@code BOOT-INFlib}目录中，并且应用程序类包含在{@code BOOT-INFclasses}目录中。
 *
 * @author Phillip Webb
 * @author Andy Wilkinson
 * @since 1.0.0
 */
public class JarLauncher extends ExecutableArchiveLauncher {
 
	static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;
 
	static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;
 
	public JarLauncher() {
	}
 
	protected JarLauncher(Archive archive) {
		super(archive);
	}
 
	@Override
	protected boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals(BOOT_INF_CLASSES);
		}
		return entry.getName().startsWith(BOOT_INF_LIB);
	}
	//main方法入口， 构造JarLauncher，然后调用它的launch方法。参数是控制台传递的
	public static void main(String[] args) throws Exception {
		new JarLauncher().launch(args);
	}
 
}
</code></pre>
<p><strong>启动类基类</strong>：org.springframework.boot.loader.Launcher-》org.springframework.boot.loader.Launcher#launch(java.lang.String[])</p>
<pre><code class="language-java">/**
 * Base class for launchers that can start an application with a fully configured
 * classpath backed by one or more {@link Archive}s.
 *	启动器的基类，可以用一个或多个{@link Archive}支持的完整配置的类路径启动应用程序。
 * @author Phillip Webb
 * @author Dave Syer
 * @since 1.0.0
 */
public abstract class Launcher {
 
	/**
	 * Launch the application. This method is the initial entry point that should be
	 * called by a subclass {@code public static void main(String[] args)} method.
	 * 启动应用程序。这个方法是一个初始入口点，它应该被子类{@code public static void main(String[] args)}方法调用。
	 * @param args the incoming arguments
	 * @throws Exception if the application fails to launch
	 */
	protected void launch(String[] args) throws Exception {
		//在系统属性中设置注册了自定义的URL处理器：org.springframework.boot.loader.jar.Handler。如果URL中没有指定处理器，会去系统属性中查询
		JarFile.registerUrlProtocolHandler();
		// getClassPathArchives方法在会去找lib目录下对应的第三方依赖JarFileArchive，同时也会项目自身的JarFileArchive
        // 根据getClassPathArchives得到的JarFileArchive集合去创建类加载器ClassLoader。这里会构造一个LaunchedURLClassLoader类加载器，这个类加载器继承URLClassLoader，并使用这些JarFileArchive集合的URL构造成URLClassPath
        // LaunchedURLClassLoader类加载器的父类加载器是当前执行类JarLauncher的类加载器
		ClassLoader classLoader = createClassLoader(getClassPathArchives());
		// getMainClass方法会去项目自身的Archive中的Manifest中找出key为Start-Class的类
		// 调用重载方法launch
		launch(args, getMainClass(), classLoader);
	}
	......
	......
}
</code></pre>
<p>可执行存档启动类的基类：org.springframework.boot.loader.ExecutableArchiveLauncher -》org.springframework.boot.loader.ExecutableArchiveLauncher#getMainClass</p>
<pre><code class="language-java">/**
 * Base class for executable archive {@link Launcher}s.
 * 可执行存档{@link启动器}的基类。
 * @author Phillip Webb
 * @author Andy Wilkinson
 * @since 1.0.0
 */
public abstract class ExecutableArchiveLauncher extends Launcher {
 
	private final Archive archive;
 
	public ExecutableArchiveLauncher() {
		try {
			this.archive = createArchive();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
 
	protected ExecutableArchiveLauncher(Archive archive) {
		this.archive = archive;
	}
 
	protected final Archive getArchive() {
		return this.archive;
	}
 
	@Override
	protected String getMainClass() throws Exception {
		//跟代码this.archive.getManifest()发现对应的是org.springframework.boot.loader.archive.JarFileArchive#getManifest
		//继续跟进入org.springframework.boot.loader.jar.JarFile#getManifest
		//最后org.springframework.boot.loader.jar.JarFile#getManifest对应的是META-INF/MANIFEST.MF文件的内容
		Manifest manifest = this.archive.getManifest();
		String mainClass = null;
		if (manifest != null) {
			//获取META-INF/MANIFEST.MF文件内容中的Start-Class，这才是我们自己写的启动类
			mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;);
		}
		if (mainClass == null) {
			throw new IllegalStateException(&quot;No 'Start-Class' manifest entry specified in &quot; + this);
		}
		return mainClass;
	}
	......
	......
}
</code></pre>
<p>到此可以看出org.springframework.boot.loader.Launcher#launch(java.lang.String[], java.lang.String, java.lang.ClassLoader)中的mainClass参数正是我们自己写的启动类，也就是META-INF/MANIFEST.MF文件中Start-Class指定的类。</p>
<p><strong>Launcher的launch方法</strong>：org.springframework.boot.loader.Launcher#launch(java.lang.String[], java.lang.String, java.lang.ClassLoader)</p>
<pre><code class="language-java">/**
 * Launch the application given the archive file and a fully configured classloader.
 * 启动应用程序，给出归档文件和一个完全配置的类加载器。
 * @param args the incoming arguments
 * @param mainClass the main class to run
 * @param classLoader the classloader
 * @throws Exception if the launch fails
 */
protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception {
	Thread.currentThread().setContextClassLoader(classLoader);
	createMainMethodRunner(mainClass, args, classLoader).run();
}
</code></pre>
<p><strong>org.springframework.boot.loader.Launcher#createMainMethodRunner</strong></p>
<pre><code class="language-java">/**
 * Create the {@code MainMethodRunner} used to launch the application.
 * @param mainClass the main class
 * @param args the incoming arguments
 * @param classLoader the classloader
 * @return the main method runner
 */
protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args, ClassLoader classLoader) {
	return new MainMethodRunner(mainClass, args);
}
</code></pre>
<p><strong>MainMethodRunner</strong>：org.springframework.boot.loader.MainMethodRunner-》org.springframework.boot.loader.MainMethodRunner#run </p>
<pre><code class="language-java">/**
 * Utility class that is used by {@link Launcher}s to call a main method. The class
 * containing the main method is loaded using the thread context class loader.
 * 被{@link Launcher}用来调用main方法的实用程序类。包含main方法的类是使用线程上下文类装入器装入的。
 * @author Phillip Webb
 * @author Andy Wilkinson
 * @since 1.0.0
 */
public class MainMethodRunner {
 
	private final String mainClassName;
 
	private final String[] args;
 
	/**
	 * Create a new {@link MainMethodRunner} instance.
	 * @param mainClass the main class
	 * @param args incoming arguments
	 */
	public MainMethodRunner(String mainClass, String[] args) {
		this.mainClassName = mainClass;
		this.args = (args != null) ? args.clone() : null;
	}
 
	public void run() throws Exception {
		Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader().loadClass(this.mainClassName);
		Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);
		mainMethod.invoke(null, new Object[] { this.args });
	}
 
}
</code></pre>
<p>上述关键代码执行流程简化如下图:</p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VmbHlpbmdz,size_16,color_FFFFFF,t_70.png" alt="img" /></p>
<p><strong>使用依赖包common</strong> </p>
<p>common 执行mvn install时，会报错提示 Unable to find a single main class。spring boot项目使用maven打包，如果没有做配置的话，会自动寻找签名是public static void main(String[] args)的方法。common 只是一个服务工程，本来就不会存在启动入口。</p>
<p>在common中添加过滤配置即可打包成功：</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;skip&gt;true&lt;/skip&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p><strong>jar启动器的作用</strong></p>
<p>当我们使用java -jar的时候 JarLauncher 会将BOOT-INF/classes下的类文件和BOOT-INF/lib下依赖的jar包加载到classpath下，最后调用META-INF下的MANIFEST.MF文件的Start-Class属性来完成应用程序的启动。</p>
<h3 id="spring-自动配置"><a class="header" href="#spring-自动配置">Spring 自动配置</a></h3>
<p>![image-20230823113954382](/Users/chouchou/Library/Application Support/typora-user-images/image-20230823113954382.png)</p>
<p>SpringBoot 自动配置，Auto-Configuration</p>
<ul>
<li>它是指基于你引入的依赖 jar 包，对 SpringBoot 应用进行自动配置</li>
<li>它是SpringBoot框架的“开箱即用”提供了基础支撑</li>
</ul>
<p>术语“配置类”，Configuration Class</p>
<ul>
<li>广义的“配置类”：被注解@Component 直接或间接修饰的某个类，即我们常说的 Spring 组件，其中包括了@Configuration 类</li>
<li>狭义的“配置类”：特指被注解 @Configuration 所修饰的某个类，又成为 @Configuration 类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230822172218836.png" alt="image-20230822172218836" /></p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230822172402498.png" alt="image-20230822172402498" /></p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230822173011734.png" alt="image-20230822173011734" /></p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230823113418389.png" alt="image-20230823113418389" /></p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230823113448199.png" alt="image-20230823113448199" /></p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230823113602551.png" alt="image-20230823113602551" /></p>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230823113646014.png" alt="image-20230823113646014" /></p>
<h4 id="conditional"><a class="header" href="#conditional">@Conditional</a></h4>
<ul>
<li>它的作用是实现：只有在特定条件满足时，才会向 IOC 容器注册指定的组件</li>
<li>我们可以将 @Conditional 理解为某种 if 语句</li>
</ul>
<p><img src="https://raw.githubusercontent.com/chou401/pic-md/master/image-20230823113909162.png" alt="image-20230823113909162" /></p>
<h4 id="conditionalonproperty"><a class="header" href="#conditionalonproperty">@ConditionalOnProperty</a></h4>
<p>该注解的作用是可以通过配置文件中的属性值来判定 configuration 是否被注入，这样就可以灵活的配置组件的启用。</p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.boot.autoconfigure.condition;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.context.annotation.Conditional;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
@Documented
@Conditional({OnPropertyCondition.class})
public @interface ConditionalOnProperty {
  	/**
     * 该属性与下面的 name 属性不可同时使用，
     * 当value所对应配置文件中的值为false时，注入不生效，不为fasle注入生效
     * value有多个值时，只要有一个值对应为false,则注入不成功
     */
    String[] value() default {};

  	/**
     * 配置文件中key的前缀，可与value 或 name 组合使用
     */
    String prefix() default &quot;&quot;;

  	/**
     * 与 value 作用一致
     */
    String[] name() default {};

  	/**
     * 与value 或 name 组合使用，只有当value 或 name 对应的值与havingValue的值相同时，注入生效
     */
    String havingValue() default &quot;&quot;;

  	/**
     * 该属性为true时，配置文件中缺少对应的value或name的对应的属性值，也会注入成功
     */
    boolean matchIfMissing() default false;
}
</code></pre>
<p>配置文件</p>
<pre><code class="language-yaml">cod:
  test: false
</code></pre>
<p>配置类</p>
<pre><code class="language-java">@Slf4j
@Component
@EnableScheduling
@ConditionalOnProperty(name = &quot;cod.test&quot;)
public class ConditionalOnPropertyTest {

    @Scheduled(cron = &quot;*/5 * * * * ?&quot;)
    public void test() {
        log.info(&quot;定时器执行。。。。&quot;);
    }
}
</code></pre>
<p>启动服务之后，只要配置了 code.test 且不为 false，都是有效的。</p>
<pre><code class="language-java">// 只要配置文件中 code.test 为 false，即使设置 matchIfMissing = true 也是无效的
// 若没有配置 code.test，则 matchIfMissing 为 true 执行，false 不执行
@ConditionalOnProperty(prefix = &quot;cod&quot;, name = &quot;test&quot;, matchIfMissing = true)
</code></pre>
<pre><code class="language-java">// 配置 code.test=111，相等于 havingValue，则执行，不同，不执行，即使设置 matchIfMissing = true 也是无效的
// 若 code.test=false，havingValue=false，则认为相等，执行
// 若没有配置 code.test，则 matchIfMissing 为 true 执行，false 不执行
@ConditionalOnProperty(prefix = &quot;cod&quot;, name = &quot;test&quot;, havingValue = &quot;111&quot;,matchIfMissing = true)
</code></pre>
<p>有配置看value，没配置看matchIfMissing。</p>
<h4 id="componentscan"><a class="header" href="#componentscan">@ComponentScan</a></h4>
<p>@ComponentScan，来自 Spring 框架的一个注解</p>
<ul>
<li>对指定的 package 进行扫描，找到其中符合条件的类，默认是搜索被注解@Component 修饰的配置类</li>
<li>通过属性 basePackages 或 basePackageClasses，来指定要进行扫描的 package</li>
<li>如果未指定 package，则默认扫描当前 @ComponentScan 所修饰的类所在的 package</li>
</ul>
<h4 id="import--configuration"><a class="header" href="#import--configuration">@Import &amp; @Configuration</a></h4>
<p>通常，<code>@Import</code> 和 <code>@Configuration</code> 共同使用，用于在容器中注册对应的 <strong>BeanDefinition</strong>。</p>
<h5 id="configuration"><a class="header" href="#configuration">@Configuration</a></h5>
<p>被 <code>@Configuration</code> 标注的类，通常称为 <strong>配置类</strong>，但配置类，并不单单指标注了 <code>@Configuration</code> 的类</p>
<ul>
<li>标注了 @Configuration 的配置类，称为 FULL 配置类，在 FULL 配置类中注册的 组件类，会在 ConfigurationClassPostProcessor#postProcessBeanFactory 方法中被 ConfigurationClassEnhancer 代理，交由 容器 处理依赖关系</li>
<li>而对于没有标注 <code>@Configuration</code>，但是标注了 <code>@Import</code> <code>Component</code> <code>ComponentScan</code> <code>ImportResource</code> 或者含有被 <code>Bean</code> 注解标注方法的配置类，称为 <strong>LITE</strong> 配置类</li>
<li>对于 FULL配置类 和 LITE配置类，ConfigurationClassPostProcessor 会委托 ConfigurationClassParser 类解析处理对应的 Component @PropertySource @ComponentScan @Import @ImportResource 注解以及标注了 @Bean 的方法</li>
</ul>
<h6 id="full--lite"><a class="header" href="#full--lite">FULL &amp; LITE</a></h6>
<p><strong>FULL配置类</strong> &amp; <strong>LITE配置类</strong> 的区别，可以看以下示例体会</p>
<pre><code class="language-java">public class A {
	public A() {
		System.out.println(&quot;...A&quot;);
	}
}

public class B {
	public B(A a) {
		System.out.println(&quot;...B&quot;);
	}
}

@Configuration
@ComponentScan(&quot;com.xsn.configurationtest&quot;)
public class MyConfigurationConfig {

	@Bean
	public A a() {
		return new A();
	}

	@Bean
	public B b() {
		return new B(a());
	}
}

public static void main(String[] args) {
	AnnotationConfigApplicationContext ac =
			new AnnotationConfigApplicationContext(MyConfigurationConfig.class);

	A a = ac.getBean(A.class);
	System.out.println(a);

	B b = ac.getBean(B.class);
	System.out.println(b);

}

结果：
FULL配置类（加了 @Configuration）：
...A
...B

LITE配置类（注释掉 @Configuration）：
...A
...A
...B

</code></pre>
<p>可以看到在 <strong>FULL配置类</strong> 下，<strong>A</strong> 和 <strong>B</strong> 的 <strong>依赖关系</strong> 将由 <strong>容器</strong> 处理。</p>
<p>我们可以看到，没有 @Configuration 修饰的时候，A 被实例化了两次。</p>
<p>现在我们搞清楚了@Configuration主要是用来做什么的了吧，它就是为了能够让我们spring，比如所我们的springboot或者spring在写上这种@Bean注解的时候（利用Java Config注解来完成对spring环境开发的时候），保证bean的一个作用域，保证它（bean）的生命周期跟它的作用域，包括Scope，Scope就是我们讲的单例（singletion）和原型（prototype）。</p>
<p>正常来说，我们在 B 中实现了 A 就应该是实例化两次，为什么会出现添加了 @Configuration 只实例化一次的情况那？</p>
<p>那么它没有执行两遍只有一个原因，你们可以思考一下，当我们一个方法调用的时候它的预期结果跟你想的不一样，那么你觉得是什么导致的。说白了，就是这个方法被改变了，这个方法不再是原来的这个方法，。因为我们这个方法，它的结果是必然的，它必然会产生一个类，但是我们调用两次它只产生一个类。那就违背了它的必然结果，那就说明了这个代码已经被别人改了。那么被随改了，肯定是被spring改了。那么按照我们现在所学的知识当中，我们要去改变一个方法的行为，没有改源码，可以用什么实现？</p>
<p>在这里用的是cglib动态代理。</p>
<p>不添加 @Configuration</p>
<pre><code class="language-java">public static void main(String[] args) {
	AnnotationConfigApplicationContext ac =
			new AnnotationConfigApplicationContext(MyConfigurationConfig.class);

	MyConfigurationConfig myConfigurationConfig = ac.getBean(MyConfigurationConfig.class);
	System.out.println(myConfigurationConfig);

}

结果：
  （注释掉 @Configuration）
  xxx.MyConfigurationConfig@2833cc44
  （加了 @Configuration）
  xxx.MyConfigurationConfig$$EnhancerBySpringCGLIB$$e52e37ff@588df31b
</code></pre>
<p>当然这里，会有疑问既然加不加 @Configuration 都可以获取 bean，那为什么还要使用那？</p>
<p>别傻了，小伙子，这里只是一个特殊情况，我们自己手动注册实现的，AnnotationConfigApplicationContext 里面会执行 this.register(componentClasses)，正常情况，不添加 @Configuration，Spring 容器根本就不会扫描，怎么可能会获取到 bean 那。</p>
<h5 id="import"><a class="header" href="#import">@Import</a></h5>
<ul>
<li>提供了一种显示地从其他地方加载配置类的方式，这样可以避免使用性能较差的组件扫描（Component Scan）</li>
<li>属性值
<ul>
<li>
<p>@Import 的属性值可以是一个 配置类，此处的配置类，可以是一个 @Configuration 注解标注的配置类（FULL 配置类）、一个标注了 @Import Component ComponentScan ImportResource 或者含有被 Bean 注解标注的方法（LITE 配置类）、甚至一个普通类</p>
</li>
<li>
<p>一个实现了 <strong>ImportSelector</strong> 的类</p>
</li>
<li>
<p>一个实现了 <strong>ImportBeanDefinitionRegistrar</strong> 的类</p>
</li>
</ul>
</li>
</ul>
<p><code>@Import</code> 和 <code>@Configuration</code> 共同使用，用于在容器中注册对应的 <strong>BeanDefinition</strong></p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {

	Class&lt;?&gt;[] value();

}
</code></pre>
<p><strong>配置类</strong></p>
<pre><code class="language-java">public class C {
	public C() {
		System.out.println(&quot;...c&quot;);
	}
}

@Configuration
@ComponentScan(&quot;com.xsn.configurationtest&quot;)
@Import(C.class)
public class MyConfigurationConfig {

}

public static void main(String[] args) {
	AnnotationConfigApplicationContext ac =
			new AnnotationConfigApplicationContext(MyConfigurationConfig.class);

	C c = ac.getBean(C.class);
	System.out.println(c);
}

结果：
com.xsn.configurationtest.C@71ba6d4e
</code></pre>
<p>类 <strong>C</strong> 就是一个普通类，同样也可以 <strong>Import</strong> 一个配置类（<strong>FULL</strong> &amp; <strong>LITE</strong>），如下</p>
<pre><code class="language-java">@Configuration
@Import(C.class)
public class ImportConfiguration {

}

@Configuration
@ComponentScan(&quot;com.xsn.configurationtest&quot;)
@Import(ImportConfiguration.class)
public class MyConfigurationConfig {

}

public static void main(String[] args) {
	AnnotationConfigApplicationContext ac =
			new AnnotationConfigApplicationContext(MyConfigurationConfig.class);

	C c = ac.getBean(C.class);
	System.out.println(c);
}

结果：
com.xsn.configurationtest.C@71ba6d4e
</code></pre>
<h6 id="importselector"><a class="header" href="#importselector">ImportSelector</a></h6>
<p>同样，<code>@Import</code> 注解可以 <strong>Import</strong> 一个 <strong>ImportSelector</strong> 的实现类</p>
<pre><code class="language-java">public interface ImportSelector {

	// 返回要 Import 的配置类名
	String[] selectImports(AnnotationMetadata importingClassMetadata);

	// 允许提供一个 Predicate 过滤 selectImports 方法对应的类
	@Nullable
	default Predicate&lt;String&gt; getExclusionFilter() {
		return null;
	}

}
</code></pre>
<p>类似于直接 Import 配置类，但是 ImportSelector 的实现类可以基于对应配置类的 AnnotationMetadata 属性进行 select，同时还可以实现各种 Aware 接口类似 EnvironmentAware BeanFactoryAware 等，持有对应的 Environment BeanFactory 来进行 select</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {

	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		StandardAnnotationMetadata standardAnnotationMetadata
				= (StandardAnnotationMetadata) importingClassMetadata;
		return new String[]{&quot;com.xsn.configurationtest.C&quot;};
	}

	@Override
	public Predicate&lt;String&gt; getExclusionFilter() {
		return null;
	}
}

@Configuration
@ComponentScan(&quot;com.xsn.configurationtest&quot;)
@Import(MyImportSelector.class)
public class MyConfigurationConfig {

}

public static void main(String[] args) {
	AnnotationConfigApplicationContext ac =
			new AnnotationConfigApplicationContext(MyConfigurationConfig.class);

	C c = ac.getBean(C.class);
	System.out.println(c);
}

结果：
com.xsn.configurationtest.C@5ab956d7
</code></pre>
<h6 id="deferredimportselector"><a class="header" href="#deferredimportselector">DeferredImportSelector</a></h6>
<p><strong>DeferredImportSelector</strong> 继承了 <strong>ImportSelector</strong>，当 <strong>Import</strong> 的是一个 <strong>DeferredImportSelector</strong> 时，该 <strong>DeferredImportSelector</strong> 会在最后解析，主要用于有 <code>@Conditional</code> 注解的配置类</p>
<h6 id="importbeandefinitionregistrar"><a class="header" href="#importbeandefinitionregistrar">ImportBeanDefinitionRegistrar</a></h6>
<p>同样，<code>@Import</code> 注解可以 <strong>Import</strong> 一个 <strong>ImportBeanDefinitionRegistrar</strong> 的实现类</p>
<pre><code class="language-java">public interface ImportBeanDefinitionRegistrar {

	// 基于 AnnotationMetadata BeanDefinitionRegistry 注册对应的 BeanDefinition
	default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
			BeanNameGenerator importBeanNameGenerator) {

		registerBeanDefinitions(importingClassMetadata, registry);
	}

	default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
	}

}
</code></pre>
<p><strong>ImportBeanDefinitionRegistrar</strong> 也可以实现各种 <strong>Aware</strong> 接口类似 <strong>EnvironmentAware</strong> <strong>BeanFactoryAware</strong> 等，持有对应的 <strong>Environment</strong> <strong>BeanFactory</strong> 来进行 <code>register</code></p>
<p>我们使用 <strong>Spring AOP</strong> 时，在配置类上添加的 <code>@EnableAspectJAutoProxy</code> 注解</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy
</code></pre>
<p>它 Import 的 AspectJAutoProxyRegistrar 便是一个 ImportBeanDefinitionRegistrar，该类会帮我们注册一个 AnnotationAwareAspectJAutoProxyCreator 的 BeanDefinition，实现 AOP 代理</p>
<h3 id="spring-自动装配"><a class="header" href="#spring-自动装配">Spring 自动装配</a></h3>
<p>自动配置：Auto-Configuration</p>
<p>自动装配：Autowire</p>
<p>这是两个不同的东西。</p>
<h4 id="spring注解发展过程"><a class="header" href="#spring注解发展过程">Spring注解发展过程</a></h4>
<p>SpringBoot的自动装配依赖于注解，所以我们先来看一下注解的发展过程。</p>
<p>以下主要对核心注解进行说明</p>
<ul>
<li>
<p><strong>Spring1.0</strong>：刚刚出现注解。</p>
<ul>
<li>@Transaction：简化了事务的操作</li>
</ul>
</li>
<li>
<p><strong>Spring2.0</strong>：一些配置开始被 xml 代替，但是还不能完全摆脱xml，主要是component-scan标签。</p>
<ul>
<li>@Required：用在set方法上，如果加上该注解，表示在xml中必须设置属性的值，不然就会报错。</li>
<li>@Aspect ：AOP相关的一个注解，用来标识配置类。</li>
<li>@Autowired，@Qualifier：依赖注入</li>
<li>@Component，@Service，@Controller，@Repository：主要是声明一些bean对象放入IOC中。</li>
<li>@RequestMapping： 声明请求对应的处理方法</li>
</ul>
</li>
<li>
<p><strong>Spring3.0</strong>：已经完全可以用注解代替xml文件了</p>
<ul>
<li>
<p>@Configuration：配置类，代理xml配置文件</p>
</li>
<li>
<p>@ComponentScan：扫描其他注解，代理xml中的component-scan标签。</p>
</li>
<li>
<p>@Import：只能用在类上，主要是用来加载第三方的类。</p>
<ul>
<li>
<p>@import(value = {XXX.class})：加载一个普通的类</p>
</li>
<li>
<p>@Import(MyImportSelector.class)：这种主要是根据业务选择性加载一些类。</p>
<pre><code class="language-java">public class MyImportSelector implements ImportSelector {//继承该接口
    @Override　　//重写selectImports方法
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        //返回对象对应的类型的全类路径的字符串数组
        return new String[]{XXX1.class.getName(), XXX2.class.getName()};
    }
}
</code></pre>
</li>
<li>
<p>@Import(MyImportBeanDefinitionRegistrar.class)：跟上面一样，都是根据业务选择性的加载一些类。只是返回的内容不一样，上面是直接返回选择的类的全路径，这个是将加载的类注册到一个BeanDefinitionRegistry中返回。</p>
<pre><code class="language-java">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {//继承该接口

    @Override   //重写registerBeanDefinitions方法
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
         // 将需要注册的对象封装为 RootBeanDefinition 对象 
        RootBeanDefinition xxx1 = new RootBeanDefinition(XXX1.class);
        registry.registerBeanDefinition(&quot;xxx1&quot;, xxx1);
        //再注册一个
        RootBeanDefinition xxx2 = new RootBeanDefinition(XXX2.class);
        registry.registerBeanDefinition(&quot;xxx2&quot;, xxx2);
    }
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Spring4.0</strong>：</p>
<ul>
<li>
<p>@Conditional：按照一定的条件进行判断，满足条件就给容器注册Bean实例。</p>
<pre><code class="language-java">/**
 * 定义一个 Condition 接口的是实现
 */
public class MyCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        //业务逻辑...
        return false; // 默认返回false
    }
}
</code></pre>
<pre><code class="language-java">//使用
@Configuration
public class JavaConfig {
    @Bean
    // 条件注解，添加的类型必须是 实现了 Condition 接口的类型
    // MyCondition的 matches 方法返回true 则注入，返回false 则不注入
    @Conditional(MyCondition.class)
    public StudentService studentService() {
        return new StudentService();
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Spring5.0</strong>:</p>
<ul>
<li>@Indexed：在Spring Boot应用场景中，大量使用@ComponentScan扫描，导致Spring模式的注解解析时间耗时增大，因此，5.0时代引入@Indexed，为Spring模式注解添加索引。
<ul>
<li>当我们在项目中使用了 @Indexed 之后，编译打包的时候会在项目中自动生成METAINT/spring.components文件。根据该文件进行扫描注入，可以提高效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="springboot自动装配原理"><a class="header" href="#springboot自动装配原理">SpringBoot自动装配原理</a></h4>
<p>自动装配还是利用了SpringFactoriesLoader来加载META-INF/spring.factoires文件里所有配置的EnableAutoConfgruation，它会经过exclude和filter等操作，最终确定要装配的类。</p>
<p><strong>1.一切的开始都源于@SpringBootApplication，它是一个组合注解</strong></p>
<p>除了元注解之外，关注这三个注解：</p>
<pre><code class="language-java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
</code></pre>
<ul>
<li>@SpringBootConfiguration该注解的作用是用来指定扫描路径的，如果不指定特定的扫描路径的话，扫描的路径是当前修饰的类所在的包及其子包。</li>
<li>@SpringBootConfiguration这个注解的本质其实是@Configuration注解。</li>
</ul>
<p><strong>2.看来这个@EnableAutoConfiguration不简单</strong></p>
<pre><code class="language-java">@Import(AutoConfigurationImportSelector.class)
</code></pre>
<p>它的内部主要是使用@import注解导入一个选择器。</p>
<p><strong>3.那么我们看看这个AutoConfigurationImportSelector类</strong></p>
<p>上文提到继承ImportSelector接口的类，需要重写 selectImports( )，那我们就看看这个方法</p>
<pre><code class="language-java">@Override
    public String[] selectImports(AnnotationMetadata annotationMetadata) {
        if (!isEnabled(annotationMetadata)) {
            return NO_IMPORTS;
        }
        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
    }
</code></pre>
<p>该方法其实也没说啥，现在的重心就放在getAutoConfigurationEntry()中。</p>
<p><strong>4.getAutoConfigurationEntry()</strong></p>
<pre><code class="language-java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }　　　　　
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
  	//获取候选配置信息,加载的是当前项目的classpath目录下的所有的 spring.factories 文件中的 key 为  
  	//org.springframework.boot.autoconfigure.EnableAutoConfiguration 的信息。
  	//点进去通过&quot;SpringFactoriesLoader&quot;进行加载
 		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
    // removeDuplicates方法的作用是 移除同名的
    configurations = removeDuplicates(configurations);
    // 获取我们配置的 exclude 信息
    // 比如：@SpringBootApplication(exclude = {RabbitAutoConfiguration.class}) ,显示的指定不要加载那个配置类
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    // filter的作用是 过滤掉咱们不需要使用的配置类。
    configurations = getConfigurationClassFilter().filter(configurations);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
}
</code></pre>
<p><strong>5.前面几个都好理解，现在我们主要看看filter()，是怎么移除不需要的类</strong></p>
<p><img src="https://github.com/chou401/pic-md/raw/master/2597186-20220218230920130-226480162.png" alt="img" /></p>
<p>我们可以看到有具体的匹配方法 match。里面有个关键的属性是 autoConfigurationMetadata , 的本质是 加载的 META-INF/spring-autoconfigure-metadata.properties 的文件中的内容。</p>
<p><img src="https://github.com/chou401/pic-md/raw/master/2597186-20220218231102908-1017908901.png" alt="img" /></p>
<p>其实原理很简单，如果没有对应的实现类，就不进行加载。</p>
<h4 id="何时进行自动装配"><a class="header" href="#何时进行自动装配">何时进行自动装配</a></h4>
<ul>
<li>处理@Configuration的核心还是ConfigurationClassPostProcessor，这个类实现了BeanFactoryPostProcessor,</li>
<li>因此当AbstractApplicationContext执行refresh方法里的invokeBeanFactoryPostProcessors(beanFactory)方法时会执行自动装配</li>
</ul>
<h4 id="run-方法"><a class="header" href="#run-方法">run 方法</a></h4>
<pre><code class="language-java">@SpringBootApplication
public class SpringBootVipDemoApplication {
    public static void main(String[] args) {
        // 基于配置文件的方式
        ApplicationContext ac1 = new ClassPathXmlApplicationContext(&quot;&quot;);
        // 基于Java配置类的方式
        ApplicationContext ac2 = new AnnotationConfigApplicationContext(SpringBootVipDemoApplication.class);
        // run 方法的返回对象是 ConfigurableApplicationContext 对象,
        //ConfigurableApplicationContext就是ApplicationContext的一个子接口
        ConfigurableApplicationContext ac3 = SpringApplication.run(SpringBootVipDemoApplication.class, args);
    }
}
</code></pre>
<p>根据返回结果，我们猜测SpringBoot项目的启动其实就是Spring的初始化操作【IOC】。</p>
<p><img src="https://github.com/chou401/pic-md/raw/master/2597186-20220218232932423-556100027.png" alt="img" /></p>
<h3 id="什么是-starter"><a class="header" href="#什么是-starter">什么是 Starter</a></h3>
<p>starter 是“一站式服务（one-stop）”的依赖 jar 包：</p>
<ul>
<li>包含Spring以及相关技术（比如 Redis）的所有依赖</li>
<li>提供了自动配置的功能，开箱即用</li>
<li>提供了良好的依赖管理，避免了包遗漏、版本冲突等问题。</li>
</ul>
<p><img src="https://github.com/chou401/pic-md/raw/master/image-20230819192249343.png" alt="image-20230819192249343" /></p>
<h3 id="maven-中的可选依赖"><a class="header" href="#maven-中的可选依赖">Maven 中的可选依赖</a></h3>
<p>可选依赖（optional）的作用：阻断“<strong>依赖传递</strong>”</p>
<h3 id="spring-中的注解处理器"><a class="header" href="#spring-中的注解处理器">Spring 中的注解处理器</a></h3>
<p>注解处理器：在编译阶段，生成指定注解的元数据。</p>
<ul>
<li>spring-boot-configuration-processor</li>
<li>spring-boot-autoconfigure-processor</li>
</ul>
<h3 id="自定义装换器"><a class="header" href="#自定义装换器">自定义装换器</a></h3>
<ol>
<li>实现WebMvcConfigurer： 不会覆盖WebMvcAutoConfiguration的配置。</li>
<li>实现WebMvcConfigurer+注解@EnableWebMvc：会覆盖WebMvcAutoConfiguration的配置。</li>
<li>继承WebMvcConfigurationSupport：会覆盖WebMvcAutoConfiguration的配置。</li>
<li>继承DelegatingWebMvcConfiguration：会覆盖WebMvcAutoConfiguration的配置。</li>
</ol>
<h4 id="配置类"><a class="header" href="#配置类">配置类</a></h4>
<h5 id="webmvcconfigurationadapter"><a class="header" href="#webmvcconfigurationadapter">WebMvcConfigurationAdapter</a></h5>
<ul>
<li>WebMvcConfigurerAdapter 是 WebMvcConfigurer 的实现类大部分为空方法，是 WebMvcConfigurer的子类实现，由于Java8中可以使用default关键字为接口添加默认方法，为在源代码中spring5.0之后就已经弃用本类，如果需要可以实现WebMvcConfigurer类。</li>
<li><code>WebMvcConfigurationAdapter</code>已经废弃，最好用<code>WebMvcConfigurer</code>代替。</li>
</ul>
<h5 id="webmvcconfigurationsupport"><a class="header" href="#webmvcconfigurationsupport">WebMvcConfigurationSupport</a></h5>
<ul>
<li>WebMvcConfigurationSupport 是mvc的基本实现并包含了WebMvcConfigurer接口中的方法。</li>
</ul>
<h5 id="webmvcautoconfiguration"><a class="header" href="#webmvcautoconfiguration">WebMvcAutoConfiguration</a></h5>
<ul>
<li>
<p>WebMvcAutoConfiguration 是mvc的自动装在类并部分包含了WebMvcConfigurer接口中的方法。</p>
</li>
<li>
<p>springboot会自动启用WebMvcAutoConfiguration类做自动加载；项目中的配置都是默认的，比如静态资源文件的访问。</p>
</li>
<li>
<pre><code class="language-java">@Configuration
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
		TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
	...
}
</code></pre>
<ul>
<li>
<p>@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})，当Spring容器中不存在WebMvcConfigurationSupportbean，WebMvcAutoConfiguration才会注入。</p>
</li>
<li>
<p>如果有配置文件继承了DelegatingWebMvcConfiguration，或者WebMvcConfigurationSupport，或者配置类注解了@EnableWebMvc，那么WebMvcAutoConfiguration 将不会被自动配置，而是使用WebMvcConfigurationSupport的配置。那么所有实现了WebMvcConfigurer的配置类有可能会全部失效。</p>
</li>
</ul>
</li>
</ul>
<h5 id="webmvcconfigurer"><a class="header" href="#webmvcconfigurer">WebMvcConfigurer</a></h5>
<ul>
<li>
<p>用途：跨域、拦截器、静态资源处理。</p>
</li>
<li>
<p>接口方法的作用：</p>
<pre><code>addInterceptors：拦截器
addViewControllers：页面跳转
addResourceHandlers：静态资源
configureDefaultServletHandling：默认静态资源处理器
configureViewResolvers：视图解析器
configureContentNegotiation：配置内容裁决的一些参数
addCorsMappings：跨域
configureMessageConverters：信息转换器
</code></pre>
</li>
<li>
<p>WebMvcConfigurer配置类其实是<code>Spring</code>内部的种配置方式，可以自定义一些Handler，Interceptor，ViewResolver，MessageConverter等等的东西对springmvc框架进行配置。</p>
</li>
<li>
<pre><code class="language-java">@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer {
    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        //创建fastJson消息转换器
        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();

        List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;MediaType&gt;();
        MediaType mediaTypeJson = MediaType.valueOf(MediaType.APPLICATION_JSON_UTF8_VALUE);
        supportedMediaTypes.add(mediaTypeJson);
        converter.setSupportedMediaTypes(supportedMediaTypes);
        //创建配置类
        FastJsonConfig config = new FastJsonConfig();
        config.getSerializeConfig().put(Json.class, new SwaggerJsonSerializer());

        //修改配置返回内容的过滤
        //WriteNullListAsEmpty  ：List字段如果为null,输出为[],而非null
        //WriteNullStringAsEmpty ： 字符类型字段如果为null,输出为&quot;&quot;,而非null
        //DisableCircularReferenceDetect ：消除对同一对象循环引用的问题，默认为false（如果不配置有可能会进入死循环）
        //WriteNullBooleanAsFalse：Boolean字段如果为null,输出为false,而非null
        //WriteMapNullValue：是否输出值为null的字段,默认为false
        //WriteDateUseDateFormat：全局修改日期格式，不添加会导致@JsonFormat失效
        config.setSerializerFeatures(SerializerFeature.WriteMapNullValue
                , SerializerFeature.WriteNonStringKeyAsString,
                SerializerFeature.WriteNullListAsEmpty,
                SerializerFeature.DisableCircularReferenceDetect,
                SerializerFeature.WriteDateUseDateFormat,
                SerializerFeature.WriteNullBooleanAsFalse);
        converter.setFastJsonConfig(config);
        //将fastjson添加到视图消息转换器列表内
        converters.add(0, converter);
        //WebMvcConfigurer失效
        converters.add(converter);
        
    }
}
</code></pre>
</li>
<li>
<p>默认已经有多个消息转换器了。而 configureMessageConverters 方法中是一个 list 参数。直接向其中添加 HttpMessageConverter后，默认是排在最后的。就造成了你自定义的消息转换器不生效。其实是被其他转换器接管了。因此，想要让我们自定义的消息转换器生效只需要把它添加到list 的第一个就可以了。</p>
</li>
<li>
<p>SerializerFeature属性</p>
<p><img src="https://github.com/chou401/pic-md/raw/master/img/image-20230203141903620.png" alt="image-20230203141903620" /></p>
</li>
</ul>
<h4 id="注解"><a class="header" href="#注解">注解</a></h4>
<h5 id="enablewebmvc"><a class="header" href="#enablewebmvc"><strong>@EnableWebMVC</strong></a></h5>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}

</code></pre>
<p>如果引用了<code>@EnableWebMVC</code>注解，就会往spring容器中注入了一个<code>DelegatingWebMvcConfiguration</code>来统一管理所有的配置类。</p>
<pre><code class="language-java">@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
	private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
	...
}

</code></pre>
<p><strong>失效问题解决</strong></p>
<ol>
<li>
<p>在类上加注解解决失效问题</p>
<pre><code class="language-java">@EnableWebMvc
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
}
</code></pre>
<p>@EnableWebMvc表示完全自己控制mvc配置，也就是说所有配置自己重写，所有默认配置都没了！有时会导致很多请求进不来，或者参数转换出错之类的，因为spring mvc默认的转换器已经不生效了,包括全局配置的Jackson也会失效，所以在大多数情况下我们需要的是在其基础配置上添加自定义配置。</p>
</li>
<li>
<p>注解+继承解决失效问题</p>
<pre><code class="language-java">@EnableWebMvc
@Configuration
public class WebMvcConfig extends WebMvcAutoConfiguration implements WebMvcConfigurer {

}
</code></pre>
</li>
</ol>
<p>@SpringBootApplication</p>
<ul>
<li>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM,
				classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
	@AliasFor(annotation = EnableAutoConfiguration.class)
	Class&lt;?&gt;[] exclude() default {};
	@AliasFor(annotation = EnableAutoConfiguration.class)
	String[] excludeName() default {};
	@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)
	String[] scanBasePackages() default {};
	@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)
	Class&lt;?&gt;[] scanBasePackageClasses() default {};
}
 
</code></pre>
<ul>
<li>这里引用了<code>@EnableAutoConfiguration</code>注解</li>
</ul>
</li>
</ul>
<h5 id="enableautoconfiguration"><a class="header" href="#enableautoconfiguration">@EnableAutoConfiguration</a></h5>
<ul>
<li>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
	String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;
	Class&lt;?&gt;[] exclude() default {};
	String[] excludeName() default {};

}
</code></pre>
</li>
<li>
<p>注解<code>@AutoConfigurationPackage</code>的主要作用就是：将主程序类所在包及所有子包下的组件到扫描到spring容器中。</p>
</li>
<li>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {
}
</code></pre>
</li>
<li>
<p><code>AutoConfigurationImportSelector</code>的作用可以参考：<a href="https://blog.csdn.net/qq_39482039/article/details/120585957">springboot源码自动装配-AutoConfigurationImportSelector</a></p>
</li>
<li>
<pre><code class="language-java">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	...
	@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		// 是否启用自动配置
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		// 获取META-INF/spring-autoconfigure-metadata.properties文件的配置，返回AutoConfigurationMetadata类
		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
				.loadMetadata(this.beanClassLoader);
		// 获取自动配置类，返回AutoConfigurationEntry
		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(
				autoConfigurationMetadata, annotationMetadata);
		// 返回要自动配置的类名
		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
	}
	...
}
</code></pre>
</li>
<li>
<p>如果引用了<code>@EnableAutoConfiguration</code>注解，就会往spring容器中注入两个类。</p>
<ol>
<li><code>AutoConfigurationPackages.Registrar</code>：扫包。</li>
<li><code>AutoConfigurationImportSelector</code>：等所有类全加载到spring容器之后扫描配置类。</li>
</ol>
</li>
</ul>
<h3 id="junit"><a class="header" href="#junit">junit</a></h3>
<p>spring boot 2，在进行单元测试的时候，<strong>不支持.yml文件</strong>，配件文件需要设置为properties。</p>
<p>pom 中增加testResources，其他操作按照正常创建 test 流程即可。</p>
<pre><code class="language-xml">&lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;${basedir}/config/${build.profile.id}/&lt;/directory&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
				&lt;finalName&gt;xxxx&lt;/finalName&gt;
        &lt;testResources&gt;
            &lt;testResource&gt;
                &lt;directory&gt;${basedir}/config/${build.profile.id}/&lt;/directory&gt;
            &lt;/testResource&gt;
            &lt;testResource&gt;
                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;
            &lt;/testResource&gt;
        &lt;/testResources&gt;
    &lt;/build&gt;
</code></pre>
<h2 id="疑问"><a class="header" href="#疑问">疑问</a></h2>
<h3 id="守护线程和用户线程有什么区别"><a class="header" href="#守护线程和用户线程有什么区别"><strong>守护线程和用户线程有什么区别？</strong></a></h3>
<ul>
<li>用户（User）线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程。</li>
<li>守护（Darmon）线程：运行在后台，为其他前台线程服务。也可以说守护线程是JVM中非守护线程的“佣人”。一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作。</li>
</ul>
<p>main函数所在的线程就是一个用户线程，main函数启动的同时在JVM内部同时启动了好多守护线程，比如垃圾回收线程。比较明显的区别之一就是用户线程结束，JVM退出，不管这个时候有没有守护线程运行。而守护线程不会影响JVM的退出。</p>
<p><strong>注意事项</strong></p>
<ol>
<li>setDaemon（true）必须在start（）方法前执行，否则会抛出 IllegalThreadStateException 异常。</li>
<li>在守护线程中产生的新线程也是守护线程。</li>
<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑。</li>
<li>守护（Darmon）线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面说过了一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作，所有守护（Daemon）线程中的finally 语句块可能无法被执行。</li>
</ol>
<h3 id="mysql56specified-key-was-too-long-max-key-length-is-767-bytes"><a class="header" href="#mysql56specified-key-was-too-long-max-key-length-is-767-bytes">MySQL5.6：Specified key was too long； max key length is 767 bytes</a></h3>
<p>在数据库中，索引的字段设置太长了，导致不支持。<strong>【根本原因：5.6版本的innodb大长度前缀默认是关闭的】</strong></p>
<p>mysql 建立索引时，数据库计算key的长度是累加所有index用到的字段的char长度，按照一定的比例乘起来不能超过限定的key长度767。</p>
<ul>
<li>latin 1 = 1 byte = 1character</li>
<li>uft8 = 3 byte = 1 character</li>
<li>utf8mb4 = 4byte = 1character</li>
<li>gbk = 2 byte = 1 character</li>
</ul>
<pre><code class="language-mysql">CREATE TABLE `xxl_job_registry` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(50) NOT NULL,
  `registry_key` varchar(190) NOT NULL,
  `registry_value` varchar(250) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `i_g_k_v` (`registry_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
 
 
registry_key 190 * 4 = 760因此创建成功
 
若将registry_key的字节数改成192，则195 * 4 = 780 则创建不成功
</code></pre>
<p>如果是联合索引时，应该是两个索引的字节加起来，然后折算成字节数。</p>
<pre><code class="language-mysql">CREATE TABLE `xxl_job_registry` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(50) NOT NULL,
  `registry_key` varchar(190) NOT NULL,
  `registry_value` varchar(110) NOT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `i_g_k_v` (`registry_key`, `registry_value`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
 
那么索引需要的字节数是：（190 + 110） * 4 = 1200
创建不成功
 
 
但是实际上呢，是能创建成功。
在创建索引的时候进行了优化，取字节数最长的那个 190 * 4 = 760因此能创建成功。
</code></pre>
<p><strong>解决方法</strong></p>
<ol>
<li>
<p>修改索引的varchar字符，只要让字符 * 字节数 &lt; 767 即可。但是有时某个字段的字符数是一定要足够大的，那就用第二种方式。</p>
</li>
<li>
<pre><code class="language-mysql">// 查看
 
show variables like &quot;innodb_large_prefix&quot;;
 
show variables like &quot;innodb_file_format&quot;;
 
//修改最大索引长度限制
set global innodb_large_prefix=1;
或
set global innodb_large_prefix=on;
 
set global innodb_file_format=BARRACUDA;
</code></pre>
</li>
</ol>
<h3 id="项目开发阶段有一个关于下单发货的需求如果今天下午-3-点前进行下单那么发货时间是明天如果今天下午-3-点后进行下单那么发货时间是后天如果被确定的时间是周日那么在此时间上再加-1-天为发货时间"><a class="header" href="#项目开发阶段有一个关于下单发货的需求如果今天下午-3-点前进行下单那么发货时间是明天如果今天下午-3-点后进行下单那么发货时间是后天如果被确定的时间是周日那么在此时间上再加-1-天为发货时间">项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间</a></h3>
<pre><code class="language-java">
final DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0);
private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime){
    DateTime orderCreateDateTime = new DateTime(orderCreateTime);
    Date tomorrow = orderCreateDateTime.plusDays(1).toDate();
    Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate();
    return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);
}
private Date wrapDistributionTime(Date distributionTime){
    DateTime currentDistributionDateTime = new DateTime(distributionTime);
    DateTime plusOneDay = currentDistributionDateTime.plusDays(1);
    boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek());
    return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;
}
</code></pre>
<h3 id="nacos-多个-ip-挂载-无法下线-did-not-find-the-leader-node"><a class="header" href="#nacos-多个-ip-挂载-无法下线-did-not-find-the-leader-node">nacos 多个 ip 挂载 无法下线 did not find the Leader node</a></h3>
<p>删除 nacos 目录下的 protocol，之后重启 nacos</p>
<pre><code class="language-c">rm -rf protocol
</code></pre>
<p>关闭nacos 服务</p>
<pre><code class="language-c">sh shutdown.sh
</code></pre>
<p>切换到bin目录，执行命令：</p>
<pre><code class="language-c">sh startup.sh -m standalone
</code></pre>
<p>后台运行</p>
<pre><code class="language-c">nohup sh startup.sh -m standalone &amp;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Slf4j.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ThreadPool.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Slf4j.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ThreadPool.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
