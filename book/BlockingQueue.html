<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BlockingQueue - chou401</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Algorithm.html"><strong aria-hidden="true">1.</strong> Algorithm</a></li><li class="chapter-item expanded "><a href="BlockingQueue.html" class="active"><strong aria-hidden="true">2.</strong> BlockingQueue</a></li><li class="chapter-item expanded "><a href="CompletableFuture.html"><strong aria-hidden="true">3.</strong> CompletableFuture</a></li><li class="chapter-item expanded "><a href="Docker.html"><strong aria-hidden="true">4.</strong> Docker</a></li><li class="chapter-item expanded "><a href="GC.html"><strong aria-hidden="true">5.</strong> GC</a></li><li class="chapter-item expanded "><a href="Interview.html"><strong aria-hidden="true">6.</strong> Interview</a></li><li class="chapter-item expanded "><a href="JDBC.html"><strong aria-hidden="true">7.</strong> JDBC</a></li><li class="chapter-item expanded "><a href="Jenkins.html"><strong aria-hidden="true">8.</strong> Jenkins</a></li><li class="chapter-item expanded "><a href="Lock.html"><strong aria-hidden="true">9.</strong> Lock</a></li><li class="chapter-item expanded "><a href="MQ.html"><strong aria-hidden="true">10.</strong> MQ</a></li><li class="chapter-item expanded "><a href="Mybatis.html"><strong aria-hidden="true">11.</strong> Mybatis</a></li><li class="chapter-item expanded "><a href="Mysql.html"><strong aria-hidden="true">12.</strong> Mysql</a></li><li class="chapter-item expanded "><a href="Netty.html"><strong aria-hidden="true">13.</strong> Netty</a></li><li class="chapter-item expanded "><a href="Slf4j.html"><strong aria-hidden="true">14.</strong> Slf4j</a></li><li class="chapter-item expanded "><a href="Spring.html"><strong aria-hidden="true">15.</strong> Spring</a></li><li class="chapter-item expanded "><a href="ThreadPool.html"><strong aria-hidden="true">16.</strong> ThreadPool</a></li><li class="chapter-item expanded "><a href="Tools.html"><strong aria-hidden="true">17.</strong> Tools</a></li><li class="chapter-item expanded "><a href="Typora.html"><strong aria-hidden="true">18.</strong> Typora</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">chou401</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chou401/chou401.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="阻塞队列"><a class="header" href="#阻塞队列">阻塞队列</a></h1>
<p>先进先出（FIFO）的数据结构，与普通队列不同的是，他支持两个附加操作，即阻塞添加和阻塞删除方法。</p>
<ul>
<li>阻塞添加：当阻塞队列是满时，往队列里添加元素的操作将被阻塞。</li>
<li>阻塞删除：当阻塞队列是空时，从队列中获取元素/删除元素的操作将被阻塞。</li>
</ul>
<p>在多线程中，阻塞的意思是，在某些情况下会 挂起线程，一旦条件成熟，被阻塞的线程就会被自动唤醒。</p>
<p>好处：</p>
<ul>
<li>阻塞队列不用手动控制什么时候该被阻塞，什么时候该被唤醒，简化了操作。</li>
</ul>
<h2 id="blockingqueue"><a class="header" href="#blockingqueue">BlockingQueue</a></h2>
<p>根据插入和取出两种类型的操作，具体分为下面一些类型：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">方法类型</th><th style="text-align: center">抛出异常</th><th style="text-align: center">返回布尔</th><th style="text-align: center">阻塞</th><th style="text-align: center">超时</th></tr></thead><tbody>
<tr><td style="text-align: center">插入</td><td style="text-align: center">add(E e)</td><td style="text-align: center">offer(E e)</td><td style="text-align: center">put(E e)</td><td style="text-align: center">offer(E e, Time, TimeUnit)</td></tr>
<tr><td style="text-align: center">取出</td><td style="text-align: center">remove()</td><td style="text-align: center">poll()</td><td style="text-align: center">take()</td><td style="text-align: center">poll(Time, TimeUnit)</td></tr>
<tr><td style="text-align: center">对首</td><td style="text-align: center">element()</td><td style="text-align: center">peek()</td><td style="text-align: center">无</td><td style="text-align: center">无</td></tr>
</tbody></table>
</div>
<ul>
<li>抛出异常是指当队列满时，再次插入会抛出异常（如果队列未满，插入返回值为true）。</li>
<li>返回布尔是指当队列满时，再次插入会返回false。</li>
<li>阻塞是指当队列满时，再次插入会被阻塞，直到队列取出一个元素，才能插入。</li>
<li>超市是指当一个时限过后，才会插入或者取出。</li>
</ul>
<blockquote>
<p>生产</p>
<p>add、offer、put这三个方法都是往队列尾部添加元素，区别如下：</p>
<ul>
<li>add：不会阻塞，添加成功时返回true，不响应中断，当队列已满导致添加失败时抛出IllegalStateException。</li>
<li>offer：不会阻塞，添加成功时返回true，因队列已满导致添加失败时返回false，不响应中断。</li>
<li>put：会阻塞，会响应中断。</li>
</ul>
<p>消费</p>
<p>take、poll方法能获取队列头部第一个元素，区别如下：</p>
<ul>
<li>take：会响应中断，会一直阻塞直到取得元素或当前线程中断。</li>
<li>poll：会响应中断，会阻塞，阻塞时间参照方法里参数timeout.timeUnit，当阻塞时间到了还没取得元素会返回null。</li>
</ul>
</blockquote>
<h2 id="arrayblockingqueue"><a class="header" href="#arrayblockingqueue">ArrayBlockingQueue</a></h2>
<ul>
<li>
<p>数据结构：静态数组，容量固定必须指定长度，没有扩容机制，没有元素的下标位置null占位。</p>
</li>
<li>
<p>锁：ReentrantLock 存取时同一把锁，操作的是同一个数组对象。</p>
</li>
<li>
<p>阻塞：</p>
<ul>
<li>
<p>notEmpty，出队：队列count为0，无元素可取时，阻塞在该对象上。</p>
</li>
<li>
<p>notFull，入队：队列count为数组的length，放不进元素时，阻塞在该对象上。</p>
</li>
</ul>
</li>
<li>
<p>入队：从对首开始添加元素，记录putIndex（到队尾时置为0），唤醒notEmpty。</p>
</li>
<li>
<p>出队：从对首开始取元素，记录takeIndex，唤醒notFull。</p>
</li>
<li>
<p>先进先出，读写互相排斥。</p>
</li>
</ul>
<p>由<strong>数组</strong>构成的<strong>有界</strong>阻塞队列，通过<strong>ReentrantLock</strong>和<strong>Condition</strong>条件队列来实现阻塞，一些成员变量如下：</p>
<pre><code class="language-java">    //存储数据
    final Object[] items;

    //返回获取数据的索引，主要用于take、poll、peek、remove方法
    int takeIndex;

    //返回添加数据的索引，主要用于 put、offer、add 方法
    int putIndex;

    // 队列元素的个数
    int count;

    //可重入锁
    final ReentrantLock lock;

    //条件对象，用于通知take方法队列的线程
    private final Condition notEmpty;

    //条件对象，用于通知put方法队列的线程
    private final Condition notFull;

	//迭代器
    transient Itrs itrs = null;


</code></pre>
<p><strong>添加元素原理</strong></p>
<p>添加方法有add，offer，put。</p>
<pre><code class="language-java">//add方法
public boolean add(E e) {
    if (offer(e))
        return true;
    else
        throw new IllegalStateException(&quot;Queue full&quot;);
}

//offer方法
public boolean offer(E e) {
    //判断是否为null
     checkNotNull(e);
     final ReentrantLock lock = this.lock;
     lock.lock();
     try {
         //判断队列是否满
         if (count == items.length)
             return false;
         else {
             //添加元素到队列
             enqueue(e);
             return true;
         }
     } finally {
         lock.unlock();
     }
 }

//元素入队操作
private void enqueue(E x) {
    //获取当前数组
    final Object[] items = this.items;
    //通过putIndex索引对数组进行赋值
    items[putIndex] = x;
    //索引自增，如果已是最后一个位置，重新设置 putIndex = 0;
    if (++putIndex == items.length)
        putIndex = 0;
    //队列中元素数量加1
    count++;
    //唤醒调用take()方法的线程，执行元素获取操作。
    notEmpty.signal();
}
</code></pre>
<p>add方法本质调用的是offer方法，而在offer的最关键处，也就是enqueue入队操作。</p>
<ol>
<li>reentrantLock保证的线程的互斥性，即统一时间只能有一个线程操作。如果队列已满，返回true，add方法则是抛出异常；如果队列未满，则开始入队操作；</li>
<li>在入队操作时，他会通过一个全局变量putIndex作为索引，指引着新来元素的位置。在这里有个小细节，就是判断putIndex是否与队列长度相等，如果队列已满，而且队列的操作时先进先出，索引下一次来插入元素的位置肯定是对头，也就是索引0的位置；</li>
<li>队内已经有元素了，然后开始唤醒take操作来消费元素。signal() 其实是 notify() 的升级版。</li>
</ol>
<p>在添加的操作中，put方法，他是会导致线程阻塞的。</p>
<pre><code class="language-java">//put方法，阻塞时可中断
public void put(E e) throws InterruptedException {
 checkNotNull(e);
  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();//该方法可中断
  try {
      //当队列元素个数与数组长度相等时，无法添加元素
      while (count == items.length)
          //将当前调用线程挂起，添加到notFull条件队列中等待唤醒
          notFull.await();
      enqueue(e);//如果队列没有满直接添加。。
  } finally {
      lock.unlock();
  }
}
</code></pre>
<p>他是通过condition的await方法来实现阻塞的，但由于又添加了lockInterruptibly标识，说明其阻塞可被打断。</p>
<p><strong>获取元素/删除元素原理</strong></p>
<p>方法有remove，poll，take。</p>
<pre><code class="language-java">public E poll() {
    //reentrantLock互斥锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        //如果队列为0,返回null，反之进入移除队列
        return (count == 0) ? null : dequeue();
    } finally {
        lock.unlock();
    }
}
//移除队列
private E dequeue() {
    //获取当前队列数据
    final Object[] items = this.items;
    @SuppressWarnings(&quot;unchecked&quot;)
    //获取当前队头数据
    E x = (E) items[takeIndex];
    //将队头数据置为null
    items[takeIndex] = null;
    //如果队头索引自增与数组长度相等，则将其索引设置为第一位
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        //更新迭代器中的元素数据
        itrs.elementDequeued();
    //唤醒put/offer/add等方法
    notFull.signal();
    return x;
}
</code></pre>
<p>poll方法是通过删除队头数据来进行移除元素，唤醒与沉睡机制采用reentrantLock 的 condition 机制。</p>
<pre><code class="language-java">public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
      lock.lockInterruptibly();//中断
      try {
          //队列没有元素，阻塞移除方法的线程
          while (count == 0)
              notEmpty.await();
          //有元素进行元素移除操作
          return dequeue();
      } finally {
          lock.unlock();
      }
}
</code></pre>
<p>take方法跟 poll方法一样，也是通过dequeue() 方法进行移除元素，但不同的是，他会进行一个线程阻塞，也就是运用condition的 awati()方法，同时这个阻塞是可被打断的，关键词lockInterruptibly。</p>
<p>remove() 方法相对来说比较复杂，他跟以上两个方法的不同点在于remove可以根据索引来删除元素，而另两个则是通过删除队列的头元素。</p>
<pre><code class="language-java">public boolean remove(Object o) {
    //确保传入元素不为null
    if (o == null) return false;
    //获取队列当前数据
    final Object[] items = this.items;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count &gt; 0) {
            final int putIndex = this.putIndex;
            int i = takeIndex;
            //找出O元素的索引值
            do {
                if (o.equals(items[i])) {//如果匹配到，删除元素，i为o的索引
                    removeAt(i);
                    return true;
                }
                //只有一个元素时，重置索引值
                if (++i == items.length)
                    i = 0;
            } while (i != putIndex);
        }
        return false;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<p>removeAt() 方法。</p>
<pre><code class="language-java">void removeAt(final int removeIndex) {
    final Object[] items = this.items;
    //判断当前元素是否是头部索引值
    if (removeIndex == takeIndex) {
        items[takeIndex] = null;
        if (++takeIndex == items.length)
            takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();
    } else {
       //如果不是，通过移动元素位置，将要删除的元素置为队尾删除
        final int putIndex = this.putIndex;
        for (int i = removeIndex;;) {
            //确保当前队列大小大于1
            int next = i + 1;
            if (next == items.length)
                next = 0;
            //如果不是队尾元素，进行元素移动
            if (next != putIndex) {
                items[i] = items[next];
                i = next;
            } else {
                //如果是队尾，元素移动完毕，直接将队尾为null，即删除
                items[i] = null;
                this.putIndex = i;
                break;
            }
        }
        count--;
        if (itrs != null)
            itrs.removedAt(removeIndex);
    }
    notFull.signal();
}
</code></pre>
<h2 id="linkedblockingqueue"><a class="header" href="#linkedblockingqueue">LinkedBlockingQueue</a></h2>
<p>由<strong>链表</strong>构成的<strong>有界</strong>阻塞队列，需要注意的是虽然是有界的，但是其默认大小是Integer.MAX_VALUE，高达21亿，一般情况下内存早爆了（在线程池中ThreadPoolExecutor有体现）。</p>
<ul>
<li>
<p>数据结构：链表Node，可以指定容量，默认为Integer.MAX_VALUE，内部类Node存储元素。</p>
</li>
<li>
<p>锁分离：存取互不排斥，操作的是不同的Node对象。</p>
<ul>
<li>
<p>takeLock：取Node节点保证前驱后继不会乱。</p>
</li>
<li>
<p>putLock：存Node节点保证前驱后继不会乱。</p>
</li>
</ul>
</li>
<li>
<p>阻塞：</p>
<ul>
<li>
<p>notEmpty，出队：队列count为0，无元素可取时，阻塞在该对象上。</p>
</li>
<li>
<p>notFull，入队：队列count为数组的length，放不进元素时，阻塞在该对象上。</p>
</li>
</ul>
</li>
<li>
<p>入队：队尾入队，记录last节点。</p>
</li>
<li>
<p>出队：队首出队，记录head节点。</p>
</li>
<li>
<p>删除元素时两个锁一起加。</p>
</li>
<li>
<p>先进先出。</p>
</li>
</ul>
<h2 id="priorityblockingqueue"><a class="header" href="#priorityblockingqueue">PriorityBlockingQueue</a></h2>
<p>支持优先级排序的无界阻塞队列。</p>
<ul>
<li>数据结构：数组 + 平衡二叉树堆，可以指定初始容量，会自动扩容，最大容量为Integer.MAX_VALUE。</li>
<li>锁：ReenLock存取东一把锁。</li>
<li>阻塞：notEmpty，出队，队列为空是阻塞。</li>
<li>入队：
<ul>
<li>不阻塞，永远返回成功，无界。</li>
<li>根绝比较器进行堆化，根据二叉堆进行排序，自下而上。</li>
</ul>
</li>
<li>出队：
<ul>
<li>弹出堆顶元素。</li>
<li>堆尾元素放到堆顶。</li>
<li>自上而下堆化。</li>
<li>为空则阻塞。</li>
</ul>
</li>
</ul>
<h2 id="delayqueue"><a class="header" href="#delayqueue">DelayQueue</a></h2>
<p>支持优先级的延迟无界阻塞队列。</p>
<h2 id="synchronousqueue"><a class="header" href="#synchronousqueue">SynchronousQueue</a></h2>
<p>单个元素的阻塞队列，队列中只有一个元素，如果想插入多个，必须等队列元素取出后，才能插入，只能有一个“坑位”，用一个插一个。</p>
<ul>
<li>
<p>存取调用同一个方法：transfer。</p>
<ul>
<li>
<p>put、offer为生产者，携带数据e，为Data模式，设置到QNode属性中。</p>
</li>
<li>
<p>take、poll为消费者，不携带数据，为Request模式，设置到QNode属性中。</p>
</li>
</ul>
</li>
<li>
<p>数据结构：链表Node。</p>
</li>
<li>
<p>锁：cas + 自旋。</p>
</li>
<li>
<p>阻塞：LockSupport。</p>
</li>
<li>
<p>判断队尾节点或者栈顶节点Node与入队模式是否相同：</p>
<ul>
<li>
<p>相同则构造节点Node入队，并阻塞当前线程，元素e和相乘赋值给Node属性。</p>
</li>
<li>
<p>不同则将元素e（部位null）返回给取数据线程，配对线程被唤醒，出队。</p>
</li>
</ul>
</li>
<li>
<p>公平模式：TransferQueue，队尾匹配，队头出队，先进先出。</p>
</li>
<li>
<p>非公平模式：TransferStack，栈顶匹配，栈顶出栈，后进先出。</p>
</li>
</ul>
<h2 id="linkedtransferqueue"><a class="header" href="#linkedtransferqueue">LinkedTransferQueue</a></h2>
<p>由链表构成的无界阻塞队列。</p>
<ul>
<li>数据结构：链表Node。</li>
<li>锁：cas + 自旋。</li>
<li>阻塞：LockSupport。</li>
<li>可以自己控制放元素需要阻塞线程，比如使用四个添加元素的方法就不会阻塞线程，只入队元素，使用transfer()会阻塞线程。</li>
<li>取元素与SynchronousQueue基本一样，都会阻塞等待有新的元素进入被匹配到。</li>
</ul>
<h2 id="linkedblockingdeque"><a class="header" href="#linkedblockingdeque">LinkedBlockingDeque</a></h2>
<p>由链表构成的双向阻塞队列。</p>
<h2 id="linkedblockingqueue和arrayblockingqueue区别"><a class="header" href="#linkedblockingqueue和arrayblockingqueue区别">LinkedBlockingQueue和ArrayBlockingQueue区别</a></h2>
<ol>
<li>
<p>队列大小不同：</p>
<ul>
<li>ArrayBlockingQueue在初始化的时候，必须指定队列的大小。</li>
<li>LinkedBlockingQueue在初始化的时候，如果没有指定大小，则会默认Integer.MAX_VALUE，是一个很大的值，这样就会导致数据再一个不可控的范围，一旦添加速度大于移除的速度时，可能会有内存泄露的风险。</li>
</ul>
</li>
<li>
<p>底层实现不同：
ArrayBlockingQueue的底层是一个数组，而LinkedBlockingQueue底层是一个链表结构。官方文档介绍中，LinkedBlockingQueue的吞吐性是高于ArrayBlockingQueue；但是在添加或移除元素，LinkedBlockingQueue则会生成一个额外的Node对象，对GC可能存在影响。</p>
<ul>
<li>
<blockquote>
<p>至于为什么说LinkedBlockingQueue的吞吐性高于ArrayBlockingQueue：</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>吞吐性强是因为有两个锁，Array里面使用的是一个锁，不管put还是take行为，都可能被这个锁卡住，而Linked里put和take是两个锁，put只会被put行为卡住，而不会被take卡住，因此吞吐性能自然强于Array。而“less
predictable performance” 这个也是显而易见的，Array采用的是固定内存，而Linked采用的是动态内存，无论是分配内存还是释放内存（甚至GC）动态内存的性能自然都会比固定内存要差。</p>
</blockquote>
</li>
<li>
<p>锁机制不一样：</p>
<p>ArrayBlockingQueue使用的一个锁控制，LinkedBlockingQueue使用两个锁控制，一个putLock，另一个takeLock，但是锁的本质都是ReentrantLock。</p>
</li>
</ol>
<p>LinkedBlockingQueue是一个基于链表实现的阻塞queue，它的性能ArrayBlockingQueue，但是差于ConcurrentLinkedQueue；并且它非常适于生产者消费者的环境中，比Executors.newFixedThreadPool()。
就是基于这个队列的，使用LinkedBlockingQueue时一定要设置容量，不然会有内存溢出的风险。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Algorithm.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="CompletableFuture.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Algorithm.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="CompletableFuture.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
