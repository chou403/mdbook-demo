<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mybatis - chou401</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Algorithm.html"><strong aria-hidden="true">1.</strong> Algorithm</a></li><li class="chapter-item expanded "><a href="BlockingQueue.html"><strong aria-hidden="true">2.</strong> BlockingQueue</a></li><li class="chapter-item expanded "><a href="CompletableFuture.html"><strong aria-hidden="true">3.</strong> CompletableFuture</a></li><li class="chapter-item expanded "><a href="Docker.html"><strong aria-hidden="true">4.</strong> docker</a></li><li class="chapter-item expanded "><a href="GC.html"><strong aria-hidden="true">5.</strong> GC</a></li><li class="chapter-item expanded "><a href="Interview.html"><strong aria-hidden="true">6.</strong> Interview</a></li><li class="chapter-item expanded "><a href="JDBC.html"><strong aria-hidden="true">7.</strong> JDBC</a></li><li class="chapter-item expanded "><a href="Jenkins.html"><strong aria-hidden="true">8.</strong> Jenkins</a></li><li class="chapter-item expanded "><a href="Lock.html"><strong aria-hidden="true">9.</strong> Lock</a></li><li class="chapter-item expanded "><a href="MQ.html"><strong aria-hidden="true">10.</strong> MQ</a></li><li class="chapter-item expanded "><a href="Mybatis.html" class="active"><strong aria-hidden="true">11.</strong> Mybatis</a></li><li class="chapter-item expanded "><a href="Mysql.html"><strong aria-hidden="true">12.</strong> Mysql</a></li><li class="chapter-item expanded "><a href="Netty.html"><strong aria-hidden="true">13.</strong> Netty</a></li><li class="chapter-item expanded "><a href="Slf4j.html"><strong aria-hidden="true">14.</strong> Slf4j</a></li><li class="chapter-item expanded "><a href="Spring.html"><strong aria-hidden="true">15.</strong> Spring</a></li><li class="chapter-item expanded "><a href="ThreadPool.html"><strong aria-hidden="true">16.</strong> ThreadPool</a></li><li class="chapter-item expanded "><a href="Tools.html"><strong aria-hidden="true">17.</strong> Tools</a></li><li class="chapter-item expanded "><a href="Typora.html"><strong aria-hidden="true">18.</strong> Typora</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">chou401</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chou401/chou401.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mybatis"><a class="header" href="#mybatis">Mybatis</a></h1>
<h2 id="mybatis使用"><a class="header" href="#mybatis使用">Mybatis使用</a></h2>
<p>ORM框架：Object Relational Mapping。用于实现面向对象编程语言里不同类型系统的数据之间的转换。</p>
<ul>
<li>
<p>添加依赖</p>
<ul>
<li>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>配置文件中配置mybatis的mapper文件位置。</p>
<ul>
<li>
<pre><code class="language-java">mybatis.mapper-locations=classpath:mapper/*.xml
</code></pre>
</li>
</ul>
</li>
<li>
<p>pom.xml 设置springboot在包中扫描xml文件。</p>
</li>
<li>
<p>启动类添加注解用于给出需要扫描的mapper文件路径@MapperScan(&quot;xxx.xxx.xxx.xxx&quot;)。</p>
</li>
<li>
<p>逆向工程依赖</p>
<pre><code class="language-java">&lt;plugin&gt;
    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;configuration&gt;
        &lt;!--允许移动生成的文件 --&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;!-- 是否覆盖 --&gt;
        &lt;overwrite&gt;true&lt;/overwrite&gt;
        &lt;!-- 自动生成的配置文件路径。启动插件时，插件会根据这里配置的路径去找到generatorConfig.xml配置文件，
        根据配置文件里的配置，去自动生成Mapper接口（可以理解为Dao层）、实体类、Mapper.xml文件
        --&gt;
        &lt;configurationFile&gt;src/main/resources/GeneratorConfig.xml&lt;/configurationFile&gt;
    &lt;/configuration&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.29&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
            &lt;version&gt;1.4.1&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;generate&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>generatorConfig.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1.0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;

    &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包 --&gt;
    &lt;!--    因为已经在pom.xml添加逆向工程插件时添加了驱动依赖，所以省略这一步--&gt;
    &lt;!--    &lt;classPathEntry  location=&quot;C:\Users\lenovo\Desktop\Software_project\java\mysql-connector-java-8.0.28/mysql-connector-java-8.0.28.jar&quot;/&gt;--&gt;

    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
        &lt;!-- 实体类生成序列化属性--&gt;
        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;
        &lt;!-- 实体类重写HashCode()和equals()--&gt;
        &lt;plugin type=&quot;org.mybatis.generator.plugins.EqualsHashCodePlugin&quot;/&gt;
        &lt;!-- 实体类重写toString() --&gt;
        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;

        &lt;commentGenerator&gt;
            &lt;!-- 是否去除自动生成的注释 --&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 生成注释是否带时间戳--&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 生成的Java文件的编码格式 --&gt;
            &lt;property name=&quot;javaFileEncoding&quot; value=&quot;utf-8&quot;/&gt;
            &lt;!-- 数据库注释支持 --&gt;
            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 时间格式设置 --&gt;
            &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
            &lt;!-- 格式化java代码--&gt;
            &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
            &lt;!-- 格式化XML代码--&gt;
            &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;!-- 数据库连接驱动类,URL，用户名、密码 --&gt;
        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://119.45.27.47:3306/dms_usp?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot;
                        userId=&quot;FordDms&quot;
                        password=&quot;FordDms.1234&quot;&gt;
            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- java类型处理器：处理DB中的类型到Java中的类型 --&gt;
        &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
            &lt;!-- 是否有效识别DB中的BigDecimal类型 --&gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;true&quot;/&gt;
        &lt;/javaTypeResolver&gt;

        &lt;!-- 生成Domain模型：包名(targetPackage)、位置(targetProject) --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.yonyou.dms.web.entity&quot; targetProject=&quot;E:\workspace\Parent\Login\src\main\java&quot;&gt;
            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法--&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
        &lt;/javaModelGenerator&gt;

        &lt;!-- 生成xml映射文件：包名(targetPackage)、位置(targetProject) --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;E:\workspace\Parent\Login\src\main\resources&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/sqlMapGenerator&gt;

        &lt;!-- 生成DAO接口：包名(targetPackage)、位置(targetProject) --&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.yonyou.dms.web.dao&quot;
                             targetProject=&quot;E:\workspace\Parent\Login\src\main\java&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/javaClientGenerator&gt;

        &lt;table tableName=&quot;tc_menu_action&quot; domainObjectName=&quot;MenuAction&quot;&gt;
            &lt;!--            若数据库中某个属性类型为text或类似类型，可能会发生无法生成这个属性，此时可以在这里指定转换类型为VARCHAR--&gt;
            &lt;!--            &lt;columnOverride column=&quot;teacher_name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;--&gt;
&lt;!--        　　table标签下的设置属性useActualColumnNames用于指定生成实体类时是否使用实际的列名作为实体类的属性名，取值true或false。--&gt;
&lt;!--        　　true：MyBatis Generator会使用数据库中实际的字段名字作为生成的实体类的属性名。--&gt;
&lt;!--        　　false：这是默认值。如果设置为false,则MyBatis Generator会将数据库中实际的字段名字转换为Camel Case风格作为生成的实体类的属性名。--&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot; /&gt;
        &lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
</li>
</ul>
<p>先执行二级缓存，再执行一级缓存。</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    CacheKey key = this.createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return this.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
</code></pre>
<p>mybatis调用query时如何使用缓存，createCacheKey生成key。</p>
<pre><code class="language-java">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {
    if (this.closed) {
        throw new ExecutorException(&quot;Executor was closed.&quot;);
    } else {
        CacheKey cacheKey = new CacheKey();
        cacheKey.update(ms.getId());
        cacheKey.update(rowBounds.getOffset());
        cacheKey.update(rowBounds.getLimit());
        cacheKey.update(boundSql.getSql());
        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
        TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
        Iterator var8 = parameterMappings.iterator();

        while(var8.hasNext()) {
            ParameterMapping parameterMapping = (ParameterMapping)var8.next();
            if (parameterMapping.getMode() != ParameterMode.OUT) {
                String propertyName = parameterMapping.getProperty();
                Object value;
                if (boundSql.hasAdditionalParameter(propertyName)) {
                    value = boundSql.getAdditionalParameter(propertyName);
                } else if (parameterObject == null) {
                    value = null;
                } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
                    value = parameterObject;
                } else {
                    MetaObject metaObject = this.configuration.newMetaObject(parameterObject);
                    value = metaObject.getValue(propertyName);
                }

                cacheKey.update(value);
            }
        }

        if (this.configuration.getEnvironment() != null) {
            cacheKey.update(this.configuration.getEnvironment().getId());
        }

        return cacheKey;
    }
}
</code></pre>
<p>执行查询方法。</p>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    // 查询时先从二级缓存中获取数据
    Cache cache = ms.getCache();
    if (cache != null) {
        this.flushCacheIfRequired(ms);
        if (ms.isUseCache() &amp;&amp; resultHandler == null) {
            this.ensureNoOutParams(ms, boundSql);
            List&lt;E&gt; list = (List)this.tcm.getObject(cache, key);
            if (list == null) {
                list = this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                this.tcm.putObject(cache, key, list);
            }

            return list;
        }
    }

    return this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
</code></pre>
<pre><code class="language-java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (this.closed) {
        throw new ExecutorException(&quot;Executor was closed.&quot;);
    } else {
        if (this.queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
            this.clearLocalCache();
        }

        List list;
        try {
            ++this.queryStack;
            // 根据key获取缓存中是否存在数据，存在数据从缓存中查询数据，否则从数据库查询数据
            list = resultHandler == null ? (List)this.localCache.getObject(key) : null;
            if (list != null) {
                this.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
            } else {
                list = this.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
            }
        } finally {
            --this.queryStack;
        }

        if (this.queryStack == 0) {
            Iterator var8 = this.deferredLoads.iterator();

            while(var8.hasNext()) {
                DeferredLoad deferredLoad = (DeferredLoad)var8.next();
                deferredLoad.load();
            }

            this.deferredLoads.clear();
            if (this.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                this.clearLocalCache();
            }
        }

        return list;
    }
}
</code></pre>
<pre><code class="language-java">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    this.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);

    List list;
    try {
        list = this.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
        this.localCache.removeObject(key);
    }

    this.localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
        this.localOutputParameterCache.putObject(key, parameter);
    }

    return list;
}
</code></pre>
<pre><code class="language-java">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    switch (ms.getStatementType()) {
            // 普通类型
        case STATEMENT:
            this.delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
            break;
            // 预编译
        case PREPARED:
            this.delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
            break;
            // 存储过程
        case CALLABLE:
            this.delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
            break;
        default:
            throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());
    }

}
</code></pre>
<pre><code class="language-java">public ResultSetWrapper(ResultSet rs, Configuration configuration) throws SQLException {
    this.typeHandlerRegistry = configuration.getTypeHandlerRegistry();
    this.resultSet = rs;
    ResultSetMetaData metaData = rs.getMetaData();
    // 获取表行数
    int columnCount = metaData.getColumnCount();

    for(int i = 1; i &lt;= columnCount; ++i) {
        // columnNames 字段名称
        this.columnNames.add(configuration.isUseColumnLabel() ? metaData.getColumnLabel(i) : metaData.getColumnName(i));
        // jdbcTypes 数据库字段类型
        this.jdbcTypes.add(JdbcType.forCode(metaData.getColumnType(i)));
        // classNames java 字段类型
        this.classNames.add(metaData.getColumnClassName(i));
    }
}
</code></pre>
<p><strong>spring整合mybatis 实现</strong></p>
<pre><code class="language-java">@Autowired
private UserMapper userMapper; // Mybatis生成的UserMapper代理对象 --&gt; Bean对象
</code></pre>
<h2 id="sqlsessionfactorybean的底层原理"><a class="header" href="#sqlsessionfactorybean的底层原理">SqlSessionFactoryBean的底层原理</a></h2>
<p>SqlSessionFactoryBean是MyBatis框架中的一个重要组件，它的主要作用是创建SqlSessionFactory对象，SqlSessionFactory是MyBatis框架中的核心对象，它负责管理MyBatis的所有配置信息，并且提供了创建SqlSession对象的方法。SqlSessionFactoryBean的底层原理是通过读取MyBatis的配置文件，解析其中的配置信息，然后根据配置信息创建SqlSessionFactory对象。在创建SqlSessionFactory对象的过程中，SqlSessionFactoryBean会使用MyBatis框架中的多个组件，包括Configuration、MapperRegistry、TypeHandlerRegistry等，这些组件都是MyBatis框架中的核心组件，它们负责管理MyBatis的各种配置信息，并且提供了各种功能的实现。SqlSessionFactoryBean的底层原理比较复杂，需要深入了解MyBatis框架的各个组件之间的关系和作用，才能更好地理解它的实现原理。</p>
<pre><code class="language-java">@Bean
public SqlSessionFactory sqlSessionFactory() throws IOException{
    InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
    return new SqlSessionFactoryBuilder().build(inputStream);
}

@Bean
public UserMapper userMapper(SqlSessionFactory sqlSessionFactory) {
    // Mybatis 代理对象
    sqlSessionFactory.getConfiguration().addMapper(UserMapper.class);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    return sqlSession.getMapper(UserMapper.class);
}
</code></pre>
<h2 id="factorybean的作用和底层工作原理"><a class="header" href="#factorybean的作用和底层工作原理">FactoryBean的作用和底层工作原理</a></h2>
<p>FactoryBean是Spring框架中的一个接口，它的作用是用于创建和管理Bean对象。FactoryBean可以将复杂的Bean对象的创建过程封装起来，使得应用程序只需要通过FactoryBean获取Bean对象即可，而不需要关心Bean对象的创建过程。FactoryBean的底层工作原理是通过实现getObject()方法来创建Bean对象，同时还可以通过实现其他方法来控制Bean对象的生命周期和行为。</p>
<pre><code class="language-java">@Component
public class TestFactoryBean implements FactoryBean {
    // 实现FactoryBean接口会生成两个Bean对象 1、TestFactoryBean 2、getObject
    // 先生成TestFactoryBean 之后再生成 getObject
    
    @Autowired
    private SqlSessionFactory sqlSessionFactory;
    
    @Override
    public Object getObject() throws Exception {
        sqlSessionFactory.getConfiguration().addMapper(UserMapper.class);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        return sqlSession.getMapper(UserMapper.class);
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return UserMapper.class;
    }
}
</code></pre>
<p>FactoryBean复用</p>
<pre><code class="language-java">AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
applicationContext.register(DegreeApplication.class);

// 与@Component 一样的作用
AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();
beanDefinition.setBeanClass(TestFactoryBean.class);
beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);
applicationContext.registerBeanDefinition(&quot;userMapper&quot;, beanDefinition);
</code></pre>
<pre><code class="language-java">@Component
public class TestFactoryBean implements FactoryBean {

  @Autowired
  private SqlSessionFactory sqlSessionFactory;

  private final Class mapperClass;

  public TestFactoryBean(Class mapperClass) {
    this.mapperClass = mapperClass;
  }

  @Override
  public Object getObject() throws Exception {
    sqlSessionFactory.getConfiguration().addMapper(mapperClass);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    return sqlSession.getMapper(mapperClass);
  }

  @Override
  public Class&lt;?&gt; getObjectType() {
    return User.class;
  }
}
</code></pre>
<h2 id="importbeandefinitionregistrar底层原理"><a class="header" href="#importbeandefinitionregistrar底层原理">ImportBeanDefinitionRegistrar底层原理</a></h2>
<ol>
<li>ImportBeanDefinitionRegistrar实现类重写registerBeanDefinitions方法。</li>
<li>在registerBeanDefinitions方法中，通过BeanDefinitionRegistry接口注册bean定义。</li>
</ol>
<pre><code class="language-java">public class TestImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        ArrayList&lt;Class&gt; list = new ArrayList&lt;&gt;();
        list.add(UserMapper.class);

        for (Class mapperClass : list) {
            AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();
            beanDefinition.setBeanClass(TestFactoryBean.class);
            beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(mapperClass);
            registry.registerBeanDefinition(mapperClass.getName(), beanDefinition);
        }
    }
}
</code></pre>
<pre><code class="language-java">// 使用@Import 导入配置的类
@Import(TestImportBeanDefinitionRegistrar.class)
public class DegreeApplication {
    
}
</code></pre>
<h2 id="mapperscannerconfigurer底层源码分析"><a class="header" href="#mapperscannerconfigurer底层源码分析">MapperScannerConfigurer底层源码分析</a></h2>
<ul>
<li>MapperScannerConfigurer底层源码分析。</li>
<li>MapperScannerConfigurer是MyBatis提供的一个BeanFactoryPostProcessor，用于扫描指定包下的Mapper接口，并将其注册到Spring容器中。</li>
<li>在MyBatis中，Mapper接口是通过MapperProxyFactory来创建代理对象的，而MapperScannerConfigurer的作用就是将Mapper接口的代理对象注册到Spring容器中，以便在需要使用Mapper接口时，可以直接从Spring容器中获取代理对象。</li>
<li>MapperScannerConfigurer的实现原理是通过Spring的ClassPathBeanDefinitionScanner来扫描指定包下的所有类，然后判断是否是Mapper接口，如果是，则将其注册到Spring容器中。</li>
<li>在注册Mapper接口时，MapperScannerConfigurer会为每个Mapper接口创建一个MapperFactoryBean，MapperFactoryBean是一个FactoryBean，用于创建Mapper接口的代理对象。</li>
<li>MapperFactoryBean的实现原理是通过MapperProxyFactory来创建Mapper接口的代理对象，然后将其返回给Spring容器。</li>
<li>总结一下，MapperScannerConfigurer的作用是将Mapper接口的代理对象注册到Spring容器中，以便在需要使用Mapper接口时，可以直接从Spring容器中获取代理对象。MapperScannerConfigurer的实现原理是通过Spring的ClassPathBeanDefinitionScanner来扫描指定包下的所有类，然后判断是否是Mapper接口，如果是，则将其注册到Spring容器中，并为每个Mapper接口创建一个MapperFactoryBean，用于创建Mapper接口的代理对象。</li>
</ul>
<pre><code class="language-java">public class TestMapperScanner extends ClassPathBeanDefinitionScanner {

    @Override
    protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
        // 是否 @component 注解
        return true;
    }

    @Override
    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        // 是否 接口类
        return beanDefinition.getMetadata().isInterface();
    }

    public TestMapperScanner(BeanDefinitionRegistry registry) {
        super(registry);
    }

    @Override
    protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
        // 重写 doScan 方法 
        Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = super.doScan(basePackages);
        for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {
            GenericBeanDefinition genericBeanDefinition = (GenericBeanDefinition) beanDefinitionHolder.getBeanDefinition();
            genericBeanDefinition.getConstructorArgumentValues().addGenericArgumentValue(Objects.requireNonNull(genericBeanDefinition.getBeanClassName()));
            genericBeanDefinition.setBeanClass(TestFactoryBean.class);
        }

        return beanDefinitionHolders;
    }
}
</code></pre>
<p>使用MapperScanner自定义扫描mapper。</p>
<pre><code class="language-java">public class TestImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        TestMapperScanner testMapperScanner = new TestMapperScanner(registry);
        testMapperScanner.scan(&quot;com.second.degree.java.mybatis.mapper&quot;);
    }
}
</code></pre>
<h2 id="mapperscan注解的底层源码分析"><a class="header" href="#mapperscan注解的底层源码分析">@MapperScan注解的底层源码分析</a></h2>
<p>@MapperScan注解是MyBatis框架提供的一个注解，用于扫描Mapper接口并将其注册到Spring容器中。其底层源码分析可以从以下几个方面入手：</p>
<ol>
<li>@MapperScan注解的定义：可以查看该注解的定义，了解其属性和作用。</li>
<li>扫描器的实现：@MapperScan注解的底层实现是通过扫描器实现的，可以查看扫描器的源码，了解其扫描的规则和实现方式。</li>
<li>注册Mapper接口：扫描器扫描到Mapper接口后，需要将其注册到Spring容器中，可以查看注册的源码，了解其实现方式和注册的规则。</li>
<li>与Spring集成：@MapperScan注解是与Spring集成的，可以查看其与Spring集成的源码，了解其实现方式和与Spring的交互方式。</li>
</ol>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(TestImportBeanDefinitionRegistrar.class)
public @interface TestMapperScan {
    String value();
}
</code></pre>
<pre><code class="language-java">@TestMapperScan(&quot;com.second.degree.java.mybatis.mapper&quot;)
public class DegreeApplication {}
</code></pre>
<pre><code class="language-java">public class TestImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

        Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(TestMapperScan.class.getName());
        String path = (String) annotationAttributes.get(&quot;value&quot;);

        TestMapperScanner testMapperScanner = new TestMapperScanner(registry);
        testMapperScanner.scan(path);
    }
}
</code></pre>
<h2 id="spring整合mybatis的底层源码分析"><a class="header" href="#spring整合mybatis的底层源码分析">Spring整合Mybatis的底层源码分析</a></h2>
<p>mybaits 2.0.6 以下版本直接在registerBeanDefinitions 中实现 Scanner 扫描器，使用注解@MapperScan。</p>
<pre><code class="language-java">@MapperScan
public class DegreeApplication {}
</code></pre>
<pre><code class="language-java">void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) {
        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
	...
}
</code></pre>
<p>mybaits 2.0.6 以上版本 是通过另一个Bean MapperScannerConfigurer 实现Scanner 扫描器，可以不使用@MapperScan，通过注册MapperScannerConfigurer 实现扫描。</p>
<pre><code class="language-java">void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) {
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
	...
}
</code></pre>
<pre><code class="language-java">public class DegreeApplication {

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer configurer = new MapperScannerConfigurer();
        configurer.setBasePackage(&quot;com.second.degree.java.mybatis.mapper&quot;);
        return configurer;
    }
}
</code></pre>
<h2 id="springboot整合mybatis的底层源码分析"><a class="header" href="#springboot整合mybatis的底层源码分析">SpringBoot整合Mybatis的底层源码分析</a></h2>
<ol>
<li>
<p>使用@MapperScan，会扫到很多无用的类，效率会差点。mybatis-spring包。</p>
</li>
<li>
<p>自动配置类MybatisAutoConfiguration。mybatis-spring-boot-autoconfigure包。</p>
<pre><code class="language-java">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    if (!AutoConfigurationPackages.has(this.beanFactory)) {
        MybatisAutoConfiguration.logger.debug(&quot;Could not determine auto-configuration package, automatic mapper scanning disabled.&quot;);
    } else {
        MybatisAutoConfiguration.logger.debug(&quot;Searching for mappers annotated with @Mapper&quot;);
        // 扫描的包路径 为 springboot 启动 run 方法的路径
        List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory);
        if (MybatisAutoConfiguration.logger.isDebugEnabled()) {
            packages.forEach((pkg) -&gt; {
                MybatisAutoConfiguration.logger.debug(&quot;Using auto-configuration base package '{}'&quot;, pkg);
            });
        }

        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
        builder.addPropertyValue(&quot;processPropertyPlaceHolders&quot;, true);
        // 只识别@Mapper 注解定义的接口类
        builder.addPropertyValue(&quot;annotationClass&quot;, Mapper.class);
        builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(packages));
        BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
        Set&lt;String&gt; propertyNames = (Set)Stream.of(beanWrapper.getPropertyDescriptors()).map(FeatureDescriptor::getName).collect(Collectors.toSet());
        if (propertyNames.contains(&quot;lazyInitialization&quot;)) {
            builder.addPropertyValue(&quot;lazyInitialization&quot;, &quot;${mybatis.lazy-initialization:false}&quot;);
        }

        if (propertyNames.contains(&quot;defaultScope&quot;)) {
            builder.addPropertyValue(&quot;defaultScope&quot;, &quot;${mybatis.mapper-default-scope:}&quot;);
        }

        boolean injectSqlSession = (Boolean)this.environment.getProperty(&quot;mybatis.inject-sql-session-on-mapper-scan&quot;, Boolean.class, Boolean.TRUE);
        if (injectSqlSession &amp;&amp; this.beanFactory instanceof ListableBeanFactory) {
            ListableBeanFactory listableBeanFactory = (ListableBeanFactory)this.beanFactory;
            Optional&lt;String&gt; sqlSessionTemplateBeanName = Optional.ofNullable(this.getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
            Optional&lt;String&gt; sqlSessionFactoryBeanName = Optional.ofNullable(this.getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
            if (!sqlSessionTemplateBeanName.isPresent() &amp;&amp; sqlSessionFactoryBeanName.isPresent()) {
                builder.addPropertyValue(&quot;sqlSessionFactoryBeanName&quot;, sqlSessionFactoryBeanName.get());
            } else {
                builder.addPropertyValue(&quot;sqlSessionTemplateBeanName&quot;, sqlSessionTemplateBeanName.orElse(&quot;sqlSessionTemplate&quot;));
            }
        }

        builder.setRole(2);
        registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }
}
</code></pre>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="MQ.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Mysql.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="MQ.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Mysql.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
